<h1 id="principle-all-apis-are-library-apis">Principle: All APIs are library APIs</h1>
<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

<!-- toc -->

<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#background">Background</a></li>
<li><a href="#principle">Principle</a></li>
<li><a href="#applications-of-this-principle">Applications of this principle</a></li>
<li><a href="#exceptions">Exceptions</a></li>
<li><a href="#alternatives-considered">Alternatives considered</a></li>
</ul>
<!-- tocstop -->

<h2 id="background">Background</h2>
<p>Every major modern programming language comes with a standard library, which consists of APIs that are not part of the core language, but instead are written in the language (although their implementations may not be). However, different languages draw the boundary between language and library in different places. For example, Go's <code>map</code> type is built into the core language, whereas the C++ equivalent, <code>std::unordered_map</code>, is part of the standard library. In Swift, even fundamental types like integers and pointers are part of the standard library; there are no truly "built in" types.</p>
<p>These decisions can have important consequences for the design of the language. For example, many important features of C++, such as move semantics, variadics, and coroutines, were motivated largely by their anticipated uses in a small set of standard library types. In a language with a different design philosophy, those types could have been built into the core language. This would probably have substantially simplified the language, and made those types available faster. However, that would have come at the cost of less flexibility for users outside the common case.</p>
<h2 id="principle">Principle</h2>
<p>In Carbon, every public function is declared in some Carbon <code>api</code> file, and every public <code>interface</code>, <code>impl</code>, and first-class type is defined in some Carbon <code>api</code> file. In some cases, the bodies of public functions will not be defined as Carbon code, or will be defined as hybrid Carbon code using intrinsics that aren't available to ordinary Carbon code. However, we will try to minimize those situations.</p>
<p>Thus, even "built-in" APIs can be used like user-defined APIs, by importing the appropriate library and using qualified names from that library, relying on the ordinary semantic rules for Carbon APIs.</p>
<h2 id="applications-of-this-principle">Applications of this principle</h2>
<p>We expect Carbon to have a special "prelude" library that is implicitly imported by all Carbon source files, and there might be a special name lookup rule to allow the names in the prelude to be used unqualified. However, in accordance with this principle, they will remain available to ordinary qualified name lookup as well.</p>
<p>According to the resolutions of <a href="https://github.com/carbon-language/carbon-lang/issues/543">#543</a> and <a href="https://github.com/carbon-language/carbon-lang/issues/543">#750</a>, Carbon will have a substantial number of type keywords, such as <code>i32</code>, <code>f64</code>, and <code>bool</code>. However, these keywords will all be aliases for ordinary type names, such as <code>Carbon.Int(32)</code>, <code>Carbon.Float(64)</code>, and <code>Carbon.Bool</code>. Furthermore, all arithmetic and logical operators will be overloadable, so that those types can be defined as class types. The member function bodies for these types will be probably not be implemented in Carbon, but this principle applies only to function declarations, not function definitions.</p>
<p>Similarly, a pointer type such as <code>Foo*</code> will be an alias for some library class type, for example <code>Carbon.Ptr(Foo)</code>. As a result, Carbon will support overloading pointer operations like <code>-&gt;</code> and unary <code>*</code>.</p>
<p>All Carbon operations that use function-style syntax, such as <code>sizeof()</code> and <code>decltype()</code> in C++, will be standard library functions. As above, in some cases we may choose to alias those functions with keywords, and the function bodies may not be defined in Carbon.</p>
<h2 id="exceptions">Exceptions</h2>
<p>This principle applies to types only if they are <em>first-class</em>, meaning that they can be the types of run-time variables, function parameters, and return values. Carbon's type system will probably also include some types whose usage is more restricted, and this principle will not apply to them. Most importantly, function types might not be first-class types, in which case they need not be library types.</p>
<p>The logic for translating a literal expression to a value of the appropriate type is arguably part of that type's public API, but will not be part of that type's class definition.</p>
<p>Tuple types will probably not fully conform to this principle, because doing so would be circular: there is no way to name a tuple type that doesn't rely on tuple syntax, and no way to define a class body for a tuple type that doesn't contain tuple patterns. However, we will strive to ensure that it is possible to define a parameterized class type within Carbon that supports all the same operations as built-in tuple types.</p>
<h2 id="alternatives-considered">Alternatives considered</h2>
<ul>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p1280.md#built-in-primitive-types">Built-in primitive types</a></li>
</ul>
