<h1 id="principle-information-accumulation">Principle: Information accumulation</h1>
<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

<!-- toc -->

<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#background">Background</a></li>
<li><a href="#principle">Principle</a></li>
<li><a href="#applications-of-this-principle">Applications of this principle</a></li>
<li><a href="#exceptions">Exceptions</a></li>
<li><a href="#alternatives-considered">Alternatives considered</a></li>
</ul>
<!-- tocstop -->

<h2 id="background">Background</h2>
<p>There are many different sources of information in a program, and a tool or a human interpreting code will not in general have full information, but will still want to draw conclusions about the code.</p>
<p>Different languages take different approaches to this problem. For example:</p>
<ul>
<li>In C, information is accumulated linearly in each source file independently, and only information from earlier in the same file is available. A program can observe that information is incomplete at one point and complete at another.</li>
<li>In C++, the behavior is largely similar to C, except:
<ul>
<li>Within certain contexts in a class, information from later in the class definition is available.</li>
<li>With C++20 modules, information from other source files can be made available.</li>
<li>It is easier to observe -- perhaps even accidentally -- that information is accumulated incrementally.</li>
</ul></li>
<li>In Rust, all information from the entire crate is available everywhere within that crate, with exceptions for constructs like proc macros that can see the state of the program being incrementally built.</li>
<li>In Swift, all information from the entire source file is available within that source file.</li>
</ul>
<h2 id="principle">Principle</h2>
<p>In Carbon, information is accumulated incrementally within each source file. Carbon programs are invalid if they would have a different meaning if more information were available.</p>
<p>Carbon source files can be interpreted top-down, without referring to information that appears substantially later in a file. Source files are expected to be organized into a topological order where that makes sense, with forward declarations used to introduce names before they are first referenced when necessary.</p>
<p>If a program attempts to use information that has not yet been provided, the program is invalid. There are multiple options for how this can be reported:</p>
<ul>
<li>The program can be rejected as soon as it tries to use information that might not be known yet.</li>
<li>For the case where the information can only be provided in the same source file, an assumption about the information can be made at the point where it is needed, and the program can be rejected only if that assumption turns out to be incorrect.</li>
</ul>
<p>Disallowing programs from changing meaning in the context of more information ensures that the program is interpreted consistently or is rejected. This is especially important to the coherence of generics and templates.</p>
<h2 id="applications-of-this-principle">Applications of this principle</h2>
<ul>
<li>As in C++, and unlike in Rust and Swift, name lookup only finds names declared earlier.</li>
<li>Classes are incomplete until the end of their definition. Unlike in C++, any attempt to observe a property of an incomplete class that is not known until the class is complete renders the program invalid.</li>
<li>When an <code>impl</code> needs to be resolved, only those <code>impl</code>s that have already been declared are considered. However, if a later <code>impl</code> would change the result of any earlier <code>impl</code> lookup, the program is invalid.</li>
</ul>
<h2 id="exceptions">Exceptions</h2>
<p>Because a class is not complete until its definition has been fully parsed, applying this rule would make it impossible to define most member functions within the class definition. In order to still provide the convenience of defining class member functions inline, such member function bodies are deferred and processed as if they appeared immediately after the end of the outermost enclosing class, like in C++.</p>
<h2 id="alternatives-considered">Alternatives considered</h2>
<ul>
<li>Allow information to be used before it is provided <a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0875.md#strict-global-consistency">globally</a>, <a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0875.md#context-sensitive-local-consistency">within a file</a>, or <a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0875.md#top-down-with-minimally-deferred-type-checking">within a top-level declaration</a>.</li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0875.md#strict-top-down">Do not allow inline method bodies to use members before they are declared</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0875.md#disallow-separate-declaration-and-definition">Do not allow separate declaration and definition</a></li>
</ul>
