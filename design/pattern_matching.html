<h1 id="pattern-matching">Pattern matching</h1>
<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

<!-- toc -->

<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#todo">TODO</a></li>
<li><a href="#overview">Overview</a>
<ul>
<li><a href="#pattern-match-control-flow">Pattern match control flow</a></li>
<li><a href="#pattern-matching-in-local-variables">Pattern matching in local variables</a></li>
</ul></li>
<li><a href="#open-questions">Open questions</a>
<ul>
<li><a href="#slice-or-array-nested-value-pattern-matching">Slice or array nested value pattern matching</a></li>
<li><a href="#generictemplate-pattern-matching">Generic/template pattern matching</a></li>
<li><a href="#pattern-matching-as-function-overload-resolution">Pattern matching as function overload resolution</a></li>
</ul></li>
</ul>
<!-- tocstop -->

<h2 id="todo">TODO</h2>
<p>This is a skeletal design, added to support <a href="index.html">the overview</a>. It should not be treated as accepted by the core team; rather, it is a placeholder until we have more time to examine this detail. Please feel welcome to rewrite and update as appropriate.</p>
<h2 id="overview">Overview</h2>
<p>The most prominent mechanism to manipulate and work with types in Carbon is pattern matching. This may seem like a deviation from C++, but in fact this is largely about building a clear, coherent model for a fundamental part of C++: overload resolution.</p>
<h3 id="pattern-match-control-flow">Pattern match control flow</h3>
<p>The most powerful form and easiest to explain form of pattern matching is a dedicated control flow construct that subsumes the <code>switch</code> of C and C++ into something much more powerful, <code>match</code>. This is not a novel construct, and is widely used in existing languages (Swift and Rust among others) and is currently under active investigation for C++. Carbon's <code>match</code> can be used as follows:</p>
<pre><code>fn Bar() -&gt; (i32, (f32, f32));
fn Foo() -&gt; f32 {
  match (Bar()) {
    case (42, (x: f32, y: f32)) =&gt; {
      return x - y;
    }
    case (p: i32, (x: f32, _: f32)) if (p &lt; 13) =&gt; {
      return p * x;
    }
    case (p: i32, _: auto) if (p &gt; 3) =&gt; {
      return p * Pi;
    }
    default =&gt; {
      return Pi;
    }
  }
}</code></pre>
<p>There is a lot going on here. First, let's break down the core structure of a <code>match</code> statement. It accepts a value that will be inspected, here the result of the call to <code>Bar()</code>. It then will find the <em>first</em> <code>case</code> that matches this value, and execute that block. If none match, then it executes the default block.</p>
<p>Each <code>case</code> contains a pattern. The first part is a value pattern (<code>(p: i32, _: auto)</code> for example) optionally followed by an <code>if</code> and boolean predicate. The value pattern has to match, and then the predicate has to evaluate to <code>true</code> for the overall pattern to match. Value patterns can be composed of the following:</p>
<ul>
<li>An expression (<code>42</code> for example), whose value must be equal to match.</li>
<li>An identifier to bind the value to, followed by a colon (<code>:</code>) and a type (<code>i32</code> for example). An underscore (<code>_</code>) may be used instead of the identifier to discard the value once matched.</li>
<li>A tuple destructuring pattern containing a tuple of value patterns (<code>(x: f32, y: f32)</code>) which match against tuples and tuple-like values by recursively matching on their elements.</li>
<li>An unwrapping pattern containing a nested value pattern which matches against a variant or variant-like value by unwrapping it.</li>
</ul>
<p>In order to match a value, whatever is specified in the pattern must match. Using <code>auto</code> for a type will always match, making <code>_: auto</code> the wildcard pattern.</p>
<h3 id="pattern-matching-in-local-variables">Pattern matching in local variables</h3>
<p>Value patterns may be used when declaring local variables to conveniently destructure them and do other type manipulations. However, the patterns must match at compile time, so they can't use an <code>if</code> clause.</p>
<pre><code>fn Bar() -&gt; (i32, (f32, f32));
fn Foo() -&gt; i32 {
  var (p: i32, _: auto) = Bar();
  return p;
}</code></pre>
<p>This extracts the first value from the result of calling <code>Bar()</code> and binds it to a local variable named <code>p</code> which is then returned.</p>
<h2 id="open-questions">Open questions</h2>
<h3 id="slice-or-array-nested-value-pattern-matching">Slice or array nested value pattern matching</h3>
<p>An open question is how to effectively fit a "slice" or "array" pattern into nested value pattern matching, or whether we shouldn't do so.</p>
<h3 id="generictemplate-pattern-matching">Generic/template pattern matching</h3>
<p>An open question is going beyond a simple "type" to things that support generics and/or templates.</p>
<h3 id="pattern-matching-as-function-overload-resolution">Pattern matching as function overload resolution</h3>
<p>Need to flesh out specific details of how overload selection leverages the pattern matching machinery, what (if any) restrictions are imposed, etc.</p>
