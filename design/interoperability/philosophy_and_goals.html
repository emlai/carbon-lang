<h1 id="interoperability-philosophy-and-goals">Interoperability philosophy and goals</h1>
<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

<!-- toc -->

<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#background">Background</a>
<ul>
<li><a href="#other-interoperability-layers">Other interoperability layers</a></li>
</ul></li>
<li><a href="#philosophy">Philosophy</a></li>
<li><a href="#language-goal-influences">Language goal influences</a>
<ul>
<li><a href="#performance-critical-software">Performance-critical software</a></li>
<li><a href="#software-and-language-evolution">Software and language evolution</a></li>
<li><a href="#code-that-is-easy-to-read-understand-and-write">Code that is easy to read, understand, and write</a></li>
<li><a href="#practical-safety-guarantees-and-testing-mechanisms">Practical safety guarantees and testing mechanisms</a></li>
<li><a href="#fast-and-scalable-development">Fast and scalable development</a></li>
<li><a href="#modern-os-platforms-hardware-architectures-and-environments">Modern OS platforms, hardware architectures, and environments</a></li>
<li><a href="#interoperability-with-and-migration-from-existing-c-code">Interoperability with and migration from existing C++ code</a></li>
</ul></li>
<li><a href="#goals">Goals</a>
<ul>
<li><a href="#support-mixing-carbon-and-c-toolchains">Support mixing Carbon and C++ toolchains</a></li>
<li><a href="#compatibility-with-the-c-memory-model">Compatibility with the C++ memory model</a></li>
<li><a href="#minimize-bridge-code">Minimize bridge code</a></li>
<li><a href="#unsurprising-mappings-between-c-and-carbon-types">Unsurprising mappings between C++ and Carbon types</a></li>
<li><a href="#allow-c-bridge-code-in-carbon-files">Allow C++ bridge code in Carbon files</a></li>
<li><a href="#carbon-inheritance-from-c-types">Carbon inheritance from C++ types</a></li>
<li><a href="#support-use-of-advanced-c-features">Support use of advanced C++ features</a></li>
<li><a href="#support-basic-c-interoperability">Support basic C interoperability</a></li>
</ul></li>
<li><a href="#non-goals">Non-goals</a>
<ul>
<li><a href="#full-parity-between-a-carbon-only-toolchain-and-mixing-ccarbon-toolchains">Full parity between a Carbon-only toolchain and mixing C++/Carbon toolchains</a></li>
<li><a href="#never-require-bridge-code">Never require bridge code</a></li>
<li><a href="#convert-all-c-types-to-carbon-types">Convert all C++ types to Carbon types</a></li>
<li><a href="#support-for-c-exceptions-without-bridge-code">Support for C++ exceptions without bridge code</a></li>
<li><a href="#cross-language-metaprogramming">Cross-language metaprogramming</a></li>
<li><a href="#offer-equivalent-support-for-languages-other-than-c">Offer equivalent support for languages other than C++</a></li>
</ul></li>
<li><a href="#open-questions-to-be-resolved-later">Open questions to be resolved later</a>
<ul>
<li><a href="#carbon-type-inheritance-from-non-pure-interface-c-types">Carbon type inheritance from non-pure interface C++ types</a></li>
<li><a href="#crtp-support">CRTP support</a></li>
<li><a href="#object-lifetimes">Object lifetimes</a></li>
</ul></li>
<li><a href="#references">References</a></li>
</ul>
<!-- tocstop -->

<h2 id="background">Background</h2>
<p>Interoperability with and migration from C++ are a <a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code">language goal</a>. However, performance and evolution are <a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/project/goals.md#language-goals-and-priorities"><em>higher</em> priorities</a>. This interaction of priorities is important to understanding Carbon's interoperability goals and trade-offs.</p>
<h3 id="other-interoperability-layers">Other interoperability layers</h3>
<p>Other language interoperability layers that may offer useful examples are:</p>
<ul>
<li><p><a href="https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html">Java/Kotlin</a> should be a comparable interoperability story. The languages are different, but share an underlying runtime. This may be closest to the model we desire for Carbon.</p></li>
<li><p><a href="https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html">JavaScript/TypeScript</a> is similar to C/C++, where one language is essentially a subset of the other, allowing high interoperability. This is an interesting reference point, but we are looking at a different approach with a clearer boundary.</p></li>
<li><p><a href="https://en.wikipedia.org/wiki/Java_Native_Interface">C++/Java</a> is an example of requiring specialized code for the bridge layer, making interoperability more burden on developers. The burden of the approach may be considered to correspond to the difference in language memory models and other language design choices. Regardless, the result can be considered higher maintenance for developers than we want for Carbon.</p></li>
<li><p><a href="https://golang.org/.html/cgo/">C++/Go</a> is similar to C++/Java. However, Go notably allows C++ bridge code to exist in the .go files, which can ease maintenance of the bridge layer, and is desirable for Carbon.</p></li>
</ul>
<h2 id="philosophy">Philosophy</h2>
<p>The C++ interoperability layer of Carbon allows a subset of C++ APIs to be accessed from Carbon code, and similarly a subset of Carbon APIs to be accessed from C++ code. This requires expressing one language as a subset of the other. Bridge code may be needed to map some APIs into the relevant subset, but the constraints on expressivity should be loose enough to keep the amount of such bridge code sustainable.</p>
<p>The design for interoperability between Carbon and C++ hinges on:</p>
<ol type="1">
<li>The ability to interoperate with a wide variety of code, such as classes/structs and templates, not just free functions.</li>
<li>A willingness to expose the idioms of C++ into Carbon code, and the other way around, when necessary to maximize performance of the interoperability layer.</li>
<li>The use of wrappers and generic programming, including templates, to minimize or eliminate runtime overhead.</li>
</ol>
<p>These things come together when looking at how custom data structures in C++ are exposed into Carbon, and the other way around. In both languages, it is reasonable and even common to have customized low-level data structures, such as associative containers. For example, there are numerous data structures for mapping from a key to a value that might be best for a particular use case, including hash tables, linked hash tables, sorted vectors, and btrees. Even for a given data structure, there may be slow but meaningful evolution in implementations strategies.</p>
<p>The result is that it will often be reasonable to directly expose a C++ data structure to Carbon without converting it to a "native" or "idiomatic" Carbon data structure. Although interfaces may differ, a trivial adapter wrapper should be sufficient. Many Carbon data structures should also be able to support multiple implementations with C++ data structures being one such implementation, allowing for idiomatic use of C++ hidden behind Carbon.</p>
<p>The reverse is also true. C++ code will often not care, or can be refactored to not care, what specific data structure is used. Carbon data structures can be exposed as yet another implementation in C++, and wrapped to match C++ idioms and even templates.</p>
<p>For example, a C++ class template like <code>std::vector&lt;T&gt;</code> should be usable without wrapper code or runtime overhead, and passing a Carbon type as <code>T</code>. The resulting type should be equally usable from either C++ or Carbon code. It should also be easy to wrap <code>std::vector&lt;T&gt;</code> with a Carbon interface for transparent use in idiomatic Carbon code.</p>
<h2 id="language-goal-influences">Language goal influences</h2>
<h3 id="performance-critical-software">Performance-critical software</h3>
<p>Interoperability with C++ will be frequently used in Carbon, whether it's C++ developers trying out Carbon, incrementally migrating a large C++ codebase, or continuing to use a C++ library long-term. In all cases, it must be possible to write interoperable code with zero overhead; copies must not be required.</p>
<h3 id="software-and-language-evolution">Software and language evolution</h3>
<p>Interoperability will require the addition of features to Carbon which exist primarily to support interoperability use cases. However, these features must not unduly impinge the overall evolution of Carbon. In particular, only a subset of Carbon features will support interoperability with C++. To do otherwise would restrict Carbon's feature set.</p>
<h3 id="code-that-is-easy-to-read-understand-and-write">Code that is easy to read, understand, and write</h3>
<p>Interoperability-related Carbon code will likely be more difficult to read than other, more idiomatic Carbon code. This is okay: aiming to make Carbon code readable doesn't mean that it needs to <em>all</em> be trivial to read. At the same time, the extra costs that interoperability exerts on Carbon developers should be minimized.</p>
<h3 id="practical-safety-guarantees-and-testing-mechanisms">Practical safety guarantees and testing mechanisms</h3>
<p>Safety is important to maintain around interoperability code, and mitigations should be provided where possible. However, safety guarantees will be focused on native Carbon code. C++ code will not benefit from the same set of safety mechanisms that Carbon offers, so Carbon code calling into C++ will accept higher safety risks.</p>
<h3 id="fast-and-scalable-development">Fast and scalable development</h3>
<p>The interoperability layer will likely have tooling limitations similar to C++. For example, Carbon aims to compile quickly. However, C++ interoperability hinges on compiling C++ code, which is relatively slow. Carbon libraries that use interoperability will see bottlenecks from C++ compile time. Improving C++ is outside the scope of Carbon.</p>
<h3 id="modern-os-platforms-hardware-architectures-and-environments">Modern OS platforms, hardware architectures, and environments</h3>
<p>Interoperability will apply to the intersection of environments supported by both Carbon and C++. Pragmatically, Carbon will likely be the limiting factor here.</p>
<h3 id="interoperability-with-and-migration-from-existing-c-code">Interoperability with and migration from existing C++ code</h3>
<p>Carbon's language goal for interoperability will focus on C++17 compatibility. The language design must be mindful of the prioritization; trade-offs harming other goals may still be made so long as they offer greater benefits for interoperability and Carbon as a whole.</p>
<p>Although the below interoperability-specific goals will focus on interoperability, it's also important to consider how migration would be affected. If interoperability requires complex work, particularly to avoid performance impacts, it could impair the ability to incrementally migrate C++ codebases to Carbon.</p>
<h2 id="goals">Goals</h2>
<h3 id="support-mixing-carbon-and-c-toolchains">Support mixing Carbon and C++ toolchains</h3>
<p>The Carbon toolchain will support compiling C++ code. It will contain a customized C++ compiler that enables some more advanced interoperability features, such as calling Carbon templates from C++.</p>
<p>Mixing toolchains will also be supported in both directions:</p>
<ul>
<li><p>C++ libraries compiled by a non-Carbon toolchain will be usable from Carbon, so long as they are ABI-compatible with Carbon's C++ toolchain.</p></li>
<li><p>The Carbon toolchain will support, as an option, generating a C++ header and object file from a Carbon library, with an ABI that's suitable for use with non-Carbon toolchains.</p></li>
</ul>
<p>Mixing toolchains restricts functionality to what's feasible with the C++ ABI. For example, developers should expect that Carbon templates will be callable from C++ when using the Carbon toolchain, and will not be available when mixing toolchains because it would require a substantially different and more complex interoperability implementation. This degraded interoperability should still be sufficient for most developers, albeit with the potential of more bridge code.</p>
<p>Any C++ interoperability code that works when mixing toolchains must work when using the native Carbon toolchain. The mixed toolchain support must not have semantic divergence. The converse is not true, and the native Carbon toolchain may have additional language support and optimizations.</p>
<h3 id="compatibility-with-the-c-memory-model">Compatibility with the C++ memory model</h3>
<p>It must be straightforward for any Carbon interoperability code to be compatible with the C++ memory model. This does not mean that Carbon must exclusively use the C++ memory model, only that it must be supported.</p>
<h3 id="minimize-bridge-code">Minimize bridge code</h3>
<p>The majority of simple C++ functions and types should be usable from Carbon without any custom bridge code and without any runtime overhead. That is, Carbon code should be able to call most C++ code without any code changes to add support for interoperability, even if that code was built with a non-Carbon toolchain. This includes instantiating Carbon templates or generics using C++ types.</p>
<p>In the other direction, Carbon may need some minimal markup to expose functions and types to C++. This should help avoid requiring Carbon to generate C++-compatible endpoints unconditionally, which could have compile and linking overheads that may in many cases be unnecessary. Also, it should help produce errors that indicate when a function or type may require additional changes to make compatible with C++.</p>
<p>Carbon's priority developers should be able to easily reuse the mature ecosystem of C++ libraries provided by third-parties. A third-party library's language choice should not be a barrier to Carbon adoption.</p>
<p>Even for first-party libraries, migration of C++ codebases to Carbon will often be incremental due to human costs of executing and verifying source migrations. Minimizing the amount of bridge code required should be expected to simplify such migrations.</p>
<h3 id="unsurprising-mappings-between-c-and-carbon-types">Unsurprising mappings between C++ and Carbon types</h3>
<p>Carbon will provide unsurprising mappings for common types.</p>
<p><strong>Primitive types</strong> will have mappings with zero overhead conversions. They are frequently used, making it important that interoperability code be able to use them seamlessly.</p>
<p>The storage and representation will need to be equivalent in both languages. For example, if a C++ <code>__int64</code> maps to Carbon's <code>Int64</code>, the memory layout of both types must be identical.</p>
<p>Semantics need to be similar, but edge-case behaviors don't need to be identical, allowing Carbon flexibility to evolve. For example, where C++ would have modulo wrapping on integers, Carbon could instead have trapping behavior on the default-mapped primitive types.</p>
<p>Carbon may have versions of these types with no C++ mapping, such as <code>Int256</code>.</p>
<p><strong>Non-owning vocabulary types</strong>, such as pointers and references, will have transparent, automatic translation between C++ and Carbon non-owning vocabulary types with zero overhead.</p>
<p><strong>Other vocabulary types</strong> will typically have reasonable, but potentially non-zero overhead, conversions available to map into Carbon vocabulary types. Code using these may choose whether to pay the overhead to convert. They may also use the C++ type directly from Carbon code, and the other way around.</p>
<p><strong>Incomplete types</strong> must have a mapping with similar semantics, similar to primitive types.</p>
<h3 id="allow-c-bridge-code-in-carbon-files">Allow C++ bridge code in Carbon files</h3>
<p>Carbon files should support inline bridge code written in C++. Where bridge code is necessary, this will allow for maintenance of it directly alongside the code that uses it.</p>
<h3 id="carbon-inheritance-from-c-types">Carbon inheritance from C++ types</h3>
<p>Carbon will support inheritance from C++ types for interoperability, although the syntax constructs may look different from C++ inheritance. This is considered necessary to address cases where a C++ library API expects users to inherit from a given C++ type.</p>
<p>This might be restricted to pure interface types; see <a href="#carbon-type-inheritance-from-non-pure-interface-c-types">the open question</a>.</p>
<h3 id="support-use-of-advanced-c-features">Support use of advanced C++ features</h3>
<p>There should be support for most idiomatic usage of advanced C++ features. A few examples are templates, overload sets, <a href="https://en.cppreference.com/w/cpp/language/attributes">attributes</a> and <a href="https://en.wikipedia.org/wiki/Argument-dependent_name_lookup">ADL</a>.</p>
<p>Although these features can be considered "advanced", their use is widespread throughout C++ code, including STL. Support for such features is key to supporting migration from C++ features.</p>
<h3 id="support-basic-c-interoperability">Support basic C interoperability</h3>
<p>C interoperability support must be sufficient for Carbon code to call popular APIs that are written in C. The ability of C to call Carbon will be more restricted, limited to where it echoes C++ interoperability support. Basic C interoperability will include functions, primitive types, and structs that only contain member variables.</p>
<p>Features where interoperability will rely on more advanced C++-specific features, such as templates, inheritance, and class functions, need not be supported for C. These would require a C-specific interoperability model that will not be included.</p>
<h2 id="non-goals">Non-goals</h2>
<h3 id="full-parity-between-a-carbon-only-toolchain-and-mixing-ccarbon-toolchains">Full parity between a Carbon-only toolchain and mixing C++/Carbon toolchains</h3>
<p>Making mixed C++/Carbon toolchain support equivalent to Carbon-only toolchain support affects all interoperability features. Mixed toolchains will have degraded support because full parity would be too expensive.</p>
<p>The feature of calling Carbon templates from C++ code is key when analyzing this option. Template instantiation during compilation is pervasive in C++.</p>
<p>With a Carbon toolchain compiling both Carbon and C++ code, the C++ compiler <em>can</em> be modified to handle Carbon templates differently. Carbon templates can be handled by exposing the Carbon compiler's AST to the C++ compiler directly, as a compiler extension. While this approach is still complex and may not always work, it should offer substantial value and ability to migrate C++ code to Carbon without requiring parallel maintenance of implementations in C++.</p>
<p>With a mixed toolchain, the C++ compiler <em>cannot</em> be modified to handle Carbon templates differently. The only way to support template instantiation would be by having Carbon templates converted into equivalent C++ templates in C++ headers; in other words, template support would require source-to-source translation. Supporting Carbon to C++ code translations would be a complex and high cost feature to achieve full parity for mixed toolchains. Requiring bridge code for mixed toolchains is the likely solution to avoid this cost.</p>
<p>Note that this issue differs when considering interoperability for Carbon code instantiating C++ templates. The C++ templates must be in C++ headers for re-use, which in turn must compile with the Carbon toolchain to re-use the built C++ code, regardless of whether a separate C++ toolchain is in use. This may also be considered a constraint on mixed toolchain interoperability, but it's simpler to address and less likely to burden developers.</p>
<p>To summarize, developers should expect that while <em>most</em> features will work equivalently for mixed toolchains, there will never be full parity.</p>
<h3 id="never-require-bridge-code">Never require bridge code</h3>
<p>Corner cases of C++ will not receive equal support to common cases: the complexity of supporting any given construct must be balanced by the real world need for that support. For example:</p>
<ul>
<li><p>Interoperability will target C++17. Any interoperability support for future versions of C++, including features such as C++20 modules, will be based on a cost-benefit analysis. Exhaustive support should not be assumed.</p></li>
<li><p>Support will be focused on idiomatic code, interfaces, and patterns used in widespread open source libraries or by other key constituencies. C++ code will have edge cases where the benefits of limiting Carbon's maintenance costs by avoiding complex interoperability outweighs the value of avoiding bridge code.</p></li>
<li><p>Support for low-level C ABIs may be focused on modern 64-bit ABIs, including Linux, POSIX, and a small subset of Windows' calling conventions.</p></li>
</ul>
<h3 id="convert-all-c-types-to-carbon-types">Convert all C++ types to Carbon types</h3>
<p>Non-zero overhead conversions should only be <em>supported</em>, never <em>required</em>, in order to offer reliable, unsurprising performance behaviors. This does not mean that conversions will <em>always</em> be supported, as support is a cost-benefit decision for specific type mappings. For example, consider conversions between <code>std::vector&lt;T&gt;</code> and an equivalent, idiomatic Carbon type:</p>
<ul>
<li><p>Making conversions zero-overhead would require the Carbon type to mirror the memory layout and implementation semantics of <code>std::vector&lt;T&gt;</code>. However, doing so would constrain the evolution of the Carbon type to match C++. Although some constraints are accepted for most primitive types, it would pose a major burden on Carbon's evolution to constrain Carbon's types to match C++ vocabulary type implementations.</p></li>
<li><p>These conversions may not always be present, but <code>std::vector&lt;T&gt;</code> is a frequently used type. As a result, it can be expected that there will be functions supporting a copy-based conversion to the idiomatic Carbon type.</p></li>
<li><p>An interface which can hide the difference between whether <code>std::vector&lt;T&gt;</code> or the equivalent, idiomatic Carbon type is in use may also be offered for common types.</p></li>
<li><p>It will still be normal to handle C++ types in Carbon code without conversions. Developers should be given the choice of when to convert.</p></li>
</ul>
<h3 id="support-for-c-exceptions-without-bridge-code">Support for C++ exceptions without bridge code</h3>
<p>Carbon may not provide seamless interoperability support for C++ exceptions. For example, translating C++ exceptions to or from Carbon errors might require annotations or bridge code, and those translations may have some performance overhead or lose information. Furthermore, if Carbon code calls a C++ function without suitable annotations or bridging, and that function exits with an exception, the program might terminate.</p>
<h3 id="cross-language-metaprogramming">Cross-language metaprogramming</h3>
<p>Carbon's metaprogramming design will be more restrictive than C++'s preprocessor macros. Although interoperability should handle simple cases, such as <code>#define STDIN_FILENO 0</code>, complex metaprogramming libraries may require a deep ability to understand code rewrites. It should be reasonable to have these instead rewritten to use Carbon's metaprogramming model.</p>
<h3 id="offer-equivalent-support-for-languages-other-than-c">Offer equivalent support for languages other than C++</h3>
<p>Long-term, it should be anticipated that Carbon will add interoperability with non-C++ languages. However, interoperability discussions will be focused on C++ in order to support the <a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code">language goal</a>. Although we should work to consider extensibility when building interoperability facilities, C++ should be expected to have more robust support.</p>
<p>Many languages do offer interoperability layers with C. Carbon's <a href="#support-basic-c-interoperability">C interoperability</a> will likely offer a degree of multi-language interoperability using C as an intermediary.</p>
<h2 id="open-questions-to-be-resolved-later">Open questions to be resolved later</h2>
<h3 id="carbon-type-inheritance-from-non-pure-interface-c-types">Carbon type inheritance from non-pure interface C++ types</h3>
<p>Some C++ APIs will expect that consumers use classes that inherit from a type provided by the API. It's desirable to have Carbon support, in some way, inheritance from API types in order to use these APIs.</p>
<p>It may be sufficient to require the parent type be a pure interface, and that APIs with either use bridge code or switch implementations. That will be determined later.</p>
<h3 id="crtp-support">CRTP support</h3>
<p>Although <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a> is a common technique in C++, interoperability support may require substantial work. Libraries based on use of CRTP may require bridge code or a rewrite for Carbon interoperability.</p>
<p>More analysis should be done on the cost-benefit of supporting CRTP before making a support decision.</p>
<h3 id="object-lifetimes">Object lifetimes</h3>
<p>Carbon may have a different object lifetime design than C++. For example, Carbon may choose different rules for determining the lifetime of temporaries. This could affect idiomatic use of C++ APIs, turning code that would be safe in C++ into unsafe Carbon code, requiring developers to learn new coding patterns.</p>
<p>More analysis should be done on object lifetimes and potential Carbon designs for it before deciding how to treat object lifetimes in the scope of interoperability.</p>
<h2 id="references">References</h2>
<ul>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/175">#175: C++ interoperability goals</a></li>
</ul>
