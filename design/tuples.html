<h1 id="tuples">Tuples</h1>
<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

<!-- toc -->

<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#todo">TODO</a></li>
<li><a href="#overview">Overview</a>
<ul>
<li><a href="#empty-tuples">Empty tuples</a></li>
<li><a href="#indices-as-compile-time-constants">Indices as compile-time constants</a></li>
<li><a href="#operations-performed-field-wise">Operations performed field-wise</a></li>
</ul></li>
<li><a href="#open-questions">Open questions</a>
<ul>
<li><a href="#slicing-ranges">Slicing ranges</a></li>
<li><a href="#single-value-tuples">Single-value tuples</a></li>
<li><a href="#function-pattern-match">Function pattern match</a></li>
<li><a href="#type-vs-tuple-of-types">Type vs tuple of types</a></li>
</ul></li>
</ul>
<!-- tocstop -->

<h2 id="todo">TODO</h2>
<p>This is a skeletal design, added to support <a href="index.html">the overview</a>. It should not be treated as accepted by the core team; rather, it is a placeholder until we have more time to examine this detail. Please feel welcome to rewrite and update as appropriate.</p>
<h2 id="overview">Overview</h2>
<p>The primary composite type involves simple aggregation of other types as a tuple (called a "product type" in formal type theory):</p>
<pre><code>fn DoubleBoth(x: i32, y: i32) -&gt; (i32, i32) {
  return (2 * x, 2 * y);
}</code></pre>
<p>This function returns a tuple of two integers represented by the type <code>(i32, i32)</code>. The expression to return it uses a special tuple syntax to build a tuple within an expression: <code>(&lt;expression&gt;, &lt;expression&gt;)</code>. This is actually the same syntax in both cases. The return type is a tuple expression, and the first and second elements are expressions referring to the <code>i32</code> type. The only difference is the type of these expressions. Both are tuples, but one is a tuple of types.</p>
<p>Element access uses subscript syntax:</p>
<pre><code>fn Bar(x: i32, y: i32) -&gt; i32 {
  var t: (i32, i32) = (x, y);
  return t[0] + t[1];
}</code></pre>
<p>Tuples also support multiple indices and slicing to restructure tuple elements:</p>
<pre><code>fn Baz(x: i32, y: i32, z: i32) -&gt; (i32, i32) {
  var t1: (i32, i32, i32) = (x, y, z);
  var t2: (i32, i32, i32) = t1[(2, 1, 0)];
  return t2[0 .. 2];
}</code></pre>
<p>This code first reverses the tuple, and then extracts a slice using a half-open range of indices.</p>
<h3 id="empty-tuples">Empty tuples</h3>
<p><code>()</code> is the empty tuple. This is used in other parts of the design, such as <a href="functions.html">functions</a>.</p>
<h3 id="indices-as-compile-time-constants">Indices as compile-time constants</h3>
<p>In the example <code>t1[(2, 1, 0)]</code>, we will likely want to restrict these indices to compile-time constants. Without that, run-time indexing would need to suddenly switch to a variant-style return type to handle heterogeneous tuples. This would both be surprising and complex for little or no value.</p>
<h3 id="operations-performed-field-wise">Operations performed field-wise</h3>
<p>Like some other aggregate data types like <a href="classes.html#struct-types">struct types</a>, there are some operations are defined for tuples field-wise:</p>
<ul>
<li>initialization</li>
<li>assignment</li>
<li>equality and inequality comparison</li>
<li>ordered comparison</li>
<li>implicit conversion for argument passing</li>
<li>destruction</li>
</ul>
<p>For binary operations, the two tuples must have the same number of components and the operation must be defined for the corresponding component types of the two tuples.</p>
<p><strong>References:</strong> The rules for assignment, comparison, and implicit conversion for argument passing were decided in <a href="https://github.com/carbon-language/carbon-lang/issues/710">question-for-leads issue #710</a>.</p>
<h2 id="open-questions">Open questions</h2>
<h3 id="slicing-ranges">Slicing ranges</h3>
<p>The intent of <code>0 .. 2</code> is to be syntax for forming a sequence of indices based on the half-open range [0, 2). There are a bunch of questions we'll need to answer here:</p>
<ul>
<li>Is this valid anywhere? Only some places?</li>
<li>What <em>is</em> the sequence?
<ul>
<li>If it is a tuple of indices, maybe that solves the above issue, and unlike function call indexing with multiple indices is different from indexing with a tuple of indexes.</li>
</ul></li>
<li>Do we need syntax for a closed range (<code>...</code> perhaps, unclear if that ends up <em>aligned</em> or in <em>conflict</em> with other likely uses of <code>...</code> in pattern matching)?</li>
<li>All of these syntaxes are also very close to <code>0.2</code>, is that similarity of syntax OK?
<ul>
<li>Do we want to require the <code>..</code> to be surrounded by whitespace to minimize that collision?</li>
</ul></li>
</ul>
<h3 id="single-value-tuples">Single-value tuples</h3>
<p>This remains an area of active investigation. There are serious problems with all approaches here. Without the collapse of one-tuples to scalars we need to distinguish between a parenthesized expression (<code>(42)</code>) and a one tuple (in Python or Rust, <code>(42,)</code>), and if we distinguish them then we cannot model a function call as simply a function name followed by a tuple of arguments; one of <code>f(0)</code> and <code>f(0,)</code> becomes a special case. With the collapse, we either break genericity by forbidding <code>(42)[0]</code> from working, or it isn't clear what it means to access a nested tuple's first element from a parenthesized expression: <code>((1, 2))[0]</code>.</p>
<h3 id="function-pattern-match">Function pattern match</h3>
<p>There are some interesting corner cases we need to expand on to fully and more precisely talk about the exact semantic model of function calls and their pattern match here, especially to handle variadic patterns and forwarding of tuples as arguments. We are hoping for a purely type system answer here without needing templates to be directly involved outside the type system as happens in C++ variadics.</p>
<h3 id="type-vs-tuple-of-types">Type vs tuple of types</h3>
<p>Is <code>(i32, i32)</code> a type, a tuple of types, or is there even a difference between the two? Is different syntax needed for these cases?</p>
