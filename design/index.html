<h1 id="language-design">Language design</h1>
<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

<!-- toc -->

<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#overview">Overview</a>
<ul>
<li><a href="#this-document-is-provisional">This document is provisional</a></li>
</ul></li>
<li><a href="#hello-carbon">Hello, Carbon</a></li>
<li><a href="#code-and-comments">Code and comments</a></li>
<li><a href="#build-modes">Build modes</a></li>
<li><a href="#types-are-values">Types are values</a></li>
<li><a href="#primitive-types">Primitive types</a>
<ul>
<li><a href="#bool"><code>bool</code></a></li>
<li><a href="#integer-types">Integer types</a>
<ul>
<li><a href="#integer-literals">Integer literals</a></li>
</ul></li>
<li><a href="#floating-point-types">Floating-point types</a>
<ul>
<li><a href="#floating-point-literals">Floating-point literals</a></li>
</ul></li>
<li><a href="#string-types">String types</a>
<ul>
<li><a href="#string-literals">String literals</a></li>
</ul></li>
</ul></li>
<li><a href="#value-categories-and-value-phases">Value categories and value phases</a></li>
<li><a href="#composite-types">Composite types</a>
<ul>
<li><a href="#tuples">Tuples</a></li>
<li><a href="#struct-types">Struct types</a></li>
<li><a href="#pointer-types">Pointer types</a></li>
<li><a href="#arrays-and-slices">Arrays and slices</a></li>
</ul></li>
<li><a href="#expressions">Expressions</a></li>
<li><a href="#declarations-definitions-and-scopes">Declarations, Definitions, and Scopes</a></li>
<li><a href="#patterns">Patterns</a>
<ul>
<li><a href="#binding-patterns">Binding patterns</a></li>
<li><a href="#destructuring-patterns">Destructuring patterns</a></li>
<li><a href="#refutable-patterns">Refutable patterns</a></li>
</ul></li>
<li><a href="#name-binding-declarations">Name-binding declarations</a>
<ul>
<li><a href="#constant-let-declarations">Constant <code>let</code> declarations</a></li>
<li><a href="#variable-var-declarations">Variable <code>var</code> declarations</a></li>
<li><a href="#auto"><code>auto</code></a></li>
</ul></li>
<li><a href="#functions">Functions</a>
<ul>
<li><a href="#parameters">Parameters</a></li>
<li><a href="#auto-return-type"><code>auto</code> return type</a></li>
<li><a href="#blocks-and-statements">Blocks and statements</a></li>
<li><a href="#assignment-statements">Assignment statements</a></li>
<li><a href="#control-flow">Control flow</a>
<ul>
<li><a href="#if-and-else"><code>if</code> and <code>else</code></a></li>
<li><a href="#loops">Loops</a>
<ul>
<li><a href="#while"><code>while</code></a></li>
<li><a href="#for"><code>for</code></a></li>
<li><a href="#break"><code>break</code></a></li>
<li><a href="#continue"><code>continue</code></a></li>
</ul></li>
<li><a href="#return"><code>return</code></a>
<ul>
<li><a href="#returned-var"><code>returned var</code></a></li>
</ul></li>
<li><a href="#match"><code>match</code></a></li>
</ul></li>
</ul></li>
<li><a href="#user-defined-types">User-defined types</a>
<ul>
<li><a href="#classes">Classes</a>
<ul>
<li><a href="#assignment">Assignment</a></li>
<li><a href="#class-functions-and-factory-functions">Class functions and factory functions</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#inheritance">Inheritance</a></li>
<li><a href="#access-control">Access control</a></li>
<li><a href="#destructors">Destructors</a></li>
<li><a href="#const"><code>const</code></a></li>
<li><a href="#unformed-state">Unformed state</a></li>
<li><a href="#move">Move</a></li>
<li><a href="#mixins">Mixins</a></li>
</ul></li>
<li><a href="#choice-types">Choice types</a></li>
</ul></li>
<li><a href="#names">Names</a>
<ul>
<li><a href="#files-libraries-packages">Files, libraries, packages</a></li>
<li><a href="#package-declaration">Package declaration</a></li>
<li><a href="#imports">Imports</a></li>
<li><a href="#name-visibility">Name visibility</a></li>
<li><a href="#package-scope">Package scope</a></li>
<li><a href="#namespaces">Namespaces</a></li>
<li><a href="#naming-conventions">Naming conventions</a></li>
<li><a href="#aliases">Aliases</a></li>
<li><a href="#name-lookup">Name lookup</a>
<ul>
<li><a href="#name-lookup-for-common-types">Name lookup for common types</a></li>
</ul></li>
</ul></li>
<li><a href="#generics">Generics</a>
<ul>
<li><a href="#checked-and-template-parameters">Checked and template parameters</a></li>
<li><a href="#interfaces-and-implementations">Interfaces and implementations</a></li>
<li><a href="#combining-constraints">Combining constraints</a></li>
<li><a href="#associated-types">Associated types</a></li>
<li><a href="#generic-entities">Generic entities</a>
<ul>
<li><a href="#generic-classes">Generic Classes</a></li>
<li><a href="#generic-choice-types">Generic choice types</a></li>
<li><a href="#generic-interfaces">Generic interfaces</a></li>
<li><a href="#generic-implementations">Generic implementations</a></li>
</ul></li>
<li><a href="#other-features">Other features</a></li>
<li><a href="#generic-type-equality-and-observe-declarations">Generic type equality and <code>observe</code> declarations</a></li>
<li><a href="#operator-overloading">Operator overloading</a>
<ul>
<li><a href="#common-type">Common type</a></li>
</ul></li>
</ul></li>
<li><a href="#bidirectional-interoperability-with-c-and-c">Bidirectional interoperability with C and C++</a>
<ul>
<li><a href="#goals">Goals</a></li>
<li><a href="#non-goals">Non-goals</a></li>
<li><a href="#importing-and-include">Importing and <code>#include</code></a></li>
<li><a href="#abi-and-dynamic-linking">ABI and dynamic linking</a></li>
<li><a href="#operator-overloading-1">Operator overloading</a></li>
<li><a href="#templates">Templates</a></li>
<li><a href="#standard-types">Standard types</a></li>
<li><a href="#inheritance-1">Inheritance</a></li>
<li><a href="#enums">Enums</a></li>
</ul></li>
<li><a href="#unfinished-tales">Unfinished tales</a>
<ul>
<li><a href="#safety">Safety</a></li>
<li><a href="#lifetime-and-move-semantics">Lifetime and move semantics</a></li>
<li><a href="#metaprogramming">Metaprogramming</a></li>
<li><a href="#pattern-matching-as-function-overload-resolution">Pattern matching as function overload resolution</a></li>
<li><a href="#error-handling">Error handling</a></li>
<li><a href="#execution-abstractions">Execution abstractions</a>
<ul>
<li><a href="#abstract-machine-and-execution-model">Abstract machine and execution model</a></li>
<li><a href="#lambdas">Lambdas</a></li>
<li><a href="#co-routines">Co-routines</a></li>
<li><a href="#concurrency">Concurrency</a></li>
</ul></li>
</ul></li>
</ul>
<!-- tocstop -->

<h2 id="overview">Overview</h2>
<p>This documentation describes the design of the Carbon language, and the rationale for that design. This documentation is an overview of the Carbon project in its current state, written for the builders of Carbon and for those interested in learning more about Carbon.</p>
<p>This document is <em>not</em> a complete programming manual, and, nor does it provide detailed and comprehensive justification for design decisions. These descriptions are found in linked dedicated designs.</p>
<h3 id="this-document-is-provisional">This document is provisional</h3>
<p>This document includes much that is provisional or placeholder. This means that the syntax used, language rules, standard library, and other aspects of the design have things that have not been decided through the Carbon process. This preliminary material fills in gaps until aspects of the design can be filled in.</p>
<h2 id="hello-carbon">Hello, Carbon</h2>
<p>Here is a simple function showing some Carbon code:</p>
<pre class="carbon"><code>import Console;

// Prints the Fibonacci numbers less than `limit`.
fn Fibonacci(limit: i64) {
  var (a: i64, b: i64) = (0, 1);
  while (a &lt; limit) {
    Console.Print(a, &quot; &quot;);
    let next: i64 = a + b;
    a = b;
    b = next;
  }
  Console.Print(&quot;\n&quot;);
}</code></pre>
<p>Carbon is a language that should feel familiar to C++ and C developers. This example has familiar constructs like <a href="#imports">imports</a>, <a href="#functions">function definitions</a>, <a href="#binding-patterns">typed arguments</a>, and <a href="#blocks-and-statements">curly braces</a>.</p>
<p>A few other features that are unlike C or C++ may stand out. First, <a href="#declarations-definitions-and-scopes">declarations</a> start with introducer keywords. <code>fn</code> introduces a function declaration, and <code>var</code> introduces a <a href="#variable-var-declarations">variable declaration</a>. You can also see a <a href="#tuples"><em>tuple</em></a>, a composite type written as a comma-separated list inside parentheses. Unlike, say, Python, these types are strongly-typed as well.</p>
<h2 id="code-and-comments">Code and comments</h2>
<p>All source code is UTF-8 encoded text. Comments, identifiers, and strings are allowed to have non-ASCII characters.</p>
<pre class="carbon"><code>var résultat: String = &quot;Succès&quot;;</code></pre>
<p>Comments start with two slashes <code>//</code> and go to the end of the line. They are required to be the only non-whitespace on the line.</p>
<pre class="carbon"><code>// Compute an approximation of π</code></pre>
<blockquote>
<p>References:</p>
<ul>
<li><a href="code_and_name_organization/source_files.html">Source files</a></li>
<li><a href="lexical_conventions">lexical conventions</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/142">#142: Unicode source files</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/198">#198: Comments</a></li>
</ul>
</blockquote>
<h2 id="build-modes">Build modes</h2>
<p>The behavior of the Carbon compiler depends on the <em>build mode</em>:</p>
<ul>
<li>In a <em>development build</em>, the priority is diagnosing problems and fast build time.</li>
<li>In a <em>performance build</em>, the priority is fastest execution time and lowest memory usage.</li>
<li>In a <em>hardened build</em>, the first priority is safety and second is performance.</li>
</ul>
<blockquote>
<p>References: <a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/project/principles/safety_strategy.md">Safety strategy</a></p>
</blockquote>
<h2 id="types-are-values">Types are values</h2>
<p>Expressions compute values in Carbon, and these values are always strongly typed much like in C++. However, an important difference from C++ is that types are themselves modeled as values; specifically, compile-time constant values. This means that the grammar for writing a type is the <a href="#expressions">expression</a> grammar. Expressions written where a type is expected must be able to be evaluated at compile-time and must evaluate to a type value.</p>
<h2 id="primitive-types">Primitive types</h2>
<p>Primitive types fall into the following categories:</p>
<ul>
<li>the boolean type <code>bool</code>,</li>
<li>signed and unsigned integer types,</li>
<li>IEEE-754 floating-point types, and</li>
<li>string types.</li>
</ul>
<p>These are made available through the <a href="#name-lookup-for-common-types">prelude</a>.</p>
<blockquote>
<p>References: <a href="primitive_types.html">Primitive types</a></p>
</blockquote>
<h3 id="bool"><code>bool</code></h3>
<p>The type <code>bool</code> is a boolean type with two possible values: <code>true</code> and <code>false</code>. <a href="#expressions">Comparison expressions</a> produce <code>bool</code> values. The condition arguments in <a href="#control-flow">control-flow statements</a>, like <a href="#if-and-else"><code>if</code></a> and <a href="#while"><code>while</code></a>, and <a href="#expressions"><code>if</code>-<code>then</code>-<code>else</code> conditional expressions</a> take <code>bool</code> values.</p>
<h3 id="integer-types">Integer types</h3>
<p>The signed-integer type with bit width <code>N</code> may be written <code>Carbon.Int(N)</code>. For convenience and brevity, the common power-of-two sizes may be written with an <code>i</code> followed by the size: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, or <code>i256</code>. Signed-integer <a href="expressions/arithmetic.html#overflow-and-other-error-conditions">overflow</a> is a programming error:</p>
<ul>
<li>In a development build, overflow will be caught immediately when it happens at runtime.</li>
<li>In a performance build, the optimizer can assume that such conditions don't occur. As a consequence, if they do, the behavior of the program is not defined.</li>
<li>In a hardened build, overflow does not result in undefined behavior. Instead, either the program will be aborted, or the arithmetic will evaluate to a mathematically incorrect result, such as a two's complement result or zero.</li>
</ul>
<p>The unsigned-integer types are: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>u256</code>, and <code>Carbon.UInt(N)</code>. Unsigned integer types wrap around on overflow, we strongly advise that they are not used except when those semantics are desired. These types are intended for bit manipulation or modular arithmetic as often found in <a href="https://en.wikipedia.org/wiki/Hash_function">hashing</a>, <a href="https://en.wikipedia.org/wiki/Cryptography">cryptography</a>, and <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator">PRNG</a> use cases. Values which can never be negative, like sizes, but for which wrapping does not make sense <a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p1083.md#dont-let-unsigned-arithmetic-wrap">should use signed integer types</a>.</p>
<blockquote>
<p>References:</p>
<ul>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/543">#543: pick names for fixed-size integer types</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/820">#820: Implicit conversions</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/1083">#1083: Arithmetic expressions</a></li>
</ul>
</blockquote>
<h4 id="integer-literals">Integer literals</h4>
<p>Integers may be written in decimal, hexadecimal, or binary:</p>
<ul>
<li><code>12345</code> (decimal)</li>
<li><code>0x1FE</code> (hexadecimal)</li>
<li><code>0b1010</code> (binary)</li>
</ul>
<p>Underscores <code>_</code> may be used as digit separators, but for decimal and hexadecimal literals, they can only appear in conventional locations. Numeric literals are case-sensitive: <code>0x</code>, <code>0b</code> must be lowercase, whereas hexadecimal digits must be uppercase. Integer literals never contain a <code>.</code>.</p>
<p>Unlike in C++, literals do not have a suffix to indicate their type. Instead, numeric literals have a type derived from their value, and can be <a href="expressions/implicit_conversions.html">implicitly converted</a> to any type that can represent that value.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="lexical_conventions/numeric_literals.html#integer-literals">Integer literals</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/143">#143: Numeric literals</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/144">#144: Numeric literal semantics</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/820">#820: Implicit conversions</a></li>
</ul>
</blockquote>
<h3 id="floating-point-types">Floating-point types</h3>
<p>Floating-point types in Carbon have IEEE 754 semantics, use the round-to-nearest rounding mode, and do not set any floating-point exception state. They are named with an <code>f</code> and the number of bits: <code>f16</code>, <code>f32</code>, <code>f64</code>, and <code>f128</code>. <a href="primitive_types.html#bfloat16"><code>BFloat16</code></a> is also provided.</p>
<blockquote>
<p>References:</p>
<ul>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/543">#543: pick names for fixed-size integer types</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/820">#820: Implicit conversions</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/1083">#1083: Arithmetic expressions</a></li>
</ul>
</blockquote>
<h4 id="floating-point-literals">Floating-point literals</h4>
<p>Floating-point types along with <a href="#user-defined-types">user-defined types</a> may initialized from <em>real-number literals</em>. Decimal and hexadecimal real-number literals are supported:</p>
<ul>
<li><code>123.456</code> (digits on both sides of the <code>.</code>)</li>
<li><code>123.456e789</code> (optional <code>+</code> or <code>-</code> after the <code>e</code>)</li>
<li><code>0x1.Ap123</code> (optional <code>+</code> or <code>-</code> after the <code>p</code>)</li>
</ul>
<p>Real-number literals always have a period (<code>.</code>) and a digit on each side of the period. When a real-number literal is interpreted as a value of a floating-point type, its value is the representable real number closest to the value of the literal. In the case of a tie, the nearest value whose mantissa is even is selected.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="lexical_conventions/numeric_literals.html#real-number-literals">Real-number literals</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/143">#143: Numeric literals</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/144">#144: Numeric literal semantics</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/820">#820: Implicit conversions</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/866">#866: Allow ties in floating literals</a></li>
</ul>
</blockquote>
<h3 id="string-types">String types</h3>
<p>There are two string types:</p>
<ul>
<li><code>String</code> - a byte sequence treated as containing UTF-8 encoded text.</li>
<li><code>StringView</code> - a read-only reference to a byte sequence treated as containing UTF-8 encoded text.</li>
</ul>
<h4 id="string-literals">String literals</h4>
<p>String literals may be written on a single line using a double quotation mark (<code>"</code>) at the beginning and end of the string, as in <code>"example"</code>.</p>
<p>Multi-line string literals, called <em>block string literals</em>, begin and end with three double quotation marks (<code>"""</code>), and may have a file type indicator after the first <code>"""</code>.</p>
<pre class="carbon"><code>// Block string literal:
var block: String = &quot;&quot;&quot;
    The winds grow high; so do your stomachs, lords.
    How irksome is this music to my heart!
    When such strings jar, what hope of harmony?
    I pray, my lords, let me compound this strife.
        -- History of Henry VI, Part II, Act II, Scene 1, W. Shakespeare
    &quot;&quot;&quot;;</code></pre>
<p>The indentation of a block string literal's terminating line is removed from all preceding lines.</p>
<p>Strings may contain <a href="lexical_conventions/string_literals.html#escape-sequences">escape sequences</a> introduced with a backslash (<code>\</code>). <a href="lexical_conventions/string_literals.html#raw-string-literals">Raw string literals</a> are available for representing strings with <code>\</code>s and <code>"</code>s.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="lexical_conventions/string_literals.html">String literals</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/199">#199: String literals</a></li>
</ul>
</blockquote>
<h2 id="value-categories-and-value-phases">Value categories and value phases</h2>
<p><strong>FIXME:</strong> Should this be moved together with <a href="#types-are-values">Types are values</a>?</p>
<p>Every value has a <a href="https://en.wikipedia.org/wiki/Value_(computer_science)#lrvalue">value category</a>, similar to <a href="https://en.cppreference.com/w/cpp/language/value_category">C++</a>, that is either <em>l-value</em> or <em>r-value</em>. Carbon will automatically convert an l-value to an r-value, but not in the other direction.</p>
<p>L-values have storage and a stable address. They may be modified, assuming their type is not <a href="#const"><code>const</code></a>.</p>
<p>R-values may not have dedicated storage. This means they cannot be modified and their address generally cannot be taken. R-values are broken down into three kinds, called <em>value phases</em>:</p>
<ul>
<li>A <em>constant</em> has a value known at compile time, and that value is available during type checking, for example to use as the size of an array. These include literals (<a href="#integer-literals">integer</a>, <a href="#floating-point-literals">floating-point</a>, <a href="#string-literals">string</a>), concrete type values (like <code>f64</code> or <code>Optional(i32*)</code>), expressions in terms of constants, and values of <a href="#checked-and-template-parameters"><code>template</code> parameters</a>.</li>
<li>A <em>symbolic value</em> has a value that will be known at the code generation stage of compilation when <a href="https://en.wikipedia.org/wiki/Monomorphization">monomorphization</a> happens, but is not known during type checking. This includes <a href="#checked-and-template-parameters">checked-generic parameters</a>, and type expressions with checked-generic arguments, like <code>Optional(T*)</code>.</li>
<li>A <em>runtime value</em> has a dynamic value only known at runtime.</li>
</ul>
<p>Carbon will automatically convert a constant to a symbolic value, or any value to a runtime value:</p>
<pre class="mermaid"><code>graph TD;
    A(constant)--&gt;B(symbolic value)--&gt;C(runtime value);
    D(l-value)--&gt;C;</code></pre>
<p>Constants convert to symbolic values and to runtime values. Symbolic values will generally convert into runtime values if an operation that inspects the value is performed on them. Runtime values will convert into constants or to symbolic values if constant evaluation of the runtime expression succeeds.</p>
<h2 id="composite-types">Composite types</h2>
<h3 id="tuples">Tuples</h3>
<p>A tuple is a fixed-size collection of values that can have different types, where each value is identified by its position in the tuple. An example use of tuples is to return multiple values from a function:</p>
<pre class="carbon"><code>fn DoubleBoth(x: i32, y: i32) -&gt; (i32, i32) {
  return (2 * x, 2 * y);
}</code></pre>
<p>Breaking this example apart:</p>
<ul>
<li>The return type is a tuple of two <code>i32</code> types.</li>
<li>The expression uses tuple syntax to build a tuple of two <code>i32</code> values.</li>
</ul>
<p>Both of these are expressions using the tuple syntax <code>(&lt;expression&gt;, &lt;expression&gt;)</code>. The only difference is the type of the tuple expression: one is a tuple of types, the other a tuple of values. In other words, a tuple type is a tuple <em>of</em> types.</p>
<p>The components of a tuple are accessed positionally, so element access uses subscript syntax, but the index must be a compile-time constant:</p>
<pre class="carbon"><code>fn DoubleTuple(x: (i32, i32)) -&gt; (i32, i32) {
  return (2 * x[0], 2 * x[1]);
}</code></pre>
<p>Tuple types are <a href="https://en.wikipedia.org/wiki/Structural_type_system">structural</a>.</p>
<blockquote>
<p>References: <a href="tuples.html">Tuples</a></p>
</blockquote>
<h3 id="struct-types">Struct types</h3>
<p>Carbon also has <a href="https://en.wikipedia.org/wiki/Structural_type_system">structural types</a> whose members are identified by name instead of position. These are called <em>structural data classes</em>, also known as a <em>struct types</em> or <em>structs</em>.</p>
<p>Both struct types and values are written inside curly braces (<code>{</code>...<code>}</code>). In both cases, they have a comma-separated list of members that start with a period (<code>.</code>) followed by the field name.</p>
<ul>
<li>In a struct type, the field name is followed by a colon (<code>:</code>) and the type, as in: <code>{.name: String, .count: i32}</code>.</li>
<li>In a struct value, called a <em>structural data class literal</em> or a <em>struct literal</em>, the field name is followed by an equal sign (<code>=</code>) and the value, as in <code>{.key = "Joe", .count = 3}</code>.</li>
</ul>
<blockquote>
<p>References:</p>
<ul>
<li><a href="classes.html#struct-types">Struct types</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/561">#561: Basic classes: use cases, struct literals, struct types, and future work</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/981">#981: Implicit conversions for aggregates</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/issues/710">#710: Default comparison for data classes</a></li>
</ul>
</blockquote>
<h3 id="pointer-types">Pointer types</h3>
<p>The type of pointers-to-values-of-type-<code>T</code> is written <code>T*</code>. Carbon pointers do not support <a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">pointer arithmetic</a>; the only pointer <a href="#expressions">operations</a> are:</p>
<ul>
<li>Dereference: given a pointer <code>p</code>, <code>*p</code> gives the value <code>p</code> points to as an <a href="#value-categories-and-value-phases">l-value</a>. <code>p-&gt;m</code> is syntactic sugar for <code>(*p).m</code>.</li>
<li>Address-of: given an <a href="#value-categories-and-value-phases">l-value</a> <code>x</code>, <code>&amp;x</code> returns a pointer to <code>x</code>.</li>
</ul>
<p>There are no <a href="https://en.wikipedia.org/wiki/Null_pointer">null pointers</a> in Carbon. To represent a pointer that may not refer to a valid object, use the type <code>Optional(T*)</code>.</p>
<p><strong>TODO:</strong> Perhaps Carbon will have <a href="https://www.ralfj.de/blog/2022/04/11/provenance-exposed.html">stricter pointer provenance</a> or restrictions on casts between pointers and integers.</p>
<blockquote>
<p>References:</p>
<ul>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/520">#520: should we use whitespace-sensitive operator fixity?</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/523">#523: what syntax should we use for pointer types?</a></li>
</ul>
</blockquote>
<h3 id="arrays-and-slices">Arrays and slices</h3>
<p>The type of an array of holding 4 <code>i32</code> values is written <code>[i32; 4]</code>. There is an <a href="expressions/implicit_conversions.html">implicit conversion</a> from tuples to arrays of the same length as long as every component of the tuple may be implicitly converted to the destination element type. In cases where the size of the array may be deduced, it may be omitted, as in:</p>
<pre class="carbon"><code>var i: i32 = 1;
// `[i32;]` equivalent to `[i32; 3]` here.
var a: [i32;] = (i, i, i);</code></pre>
<p>Elements of an array may be accessed using square brackets (<code>[</code>...<code>]</code>), as in <code>a[i]</code>:</p>
<pre class="carbon"><code>a[i] = 2;
Console.Print(a[0]);</code></pre>
<blockquote>
<p><strong>TODO:</strong> Slices</p>
</blockquote>
<h2 id="expressions">Expressions</h2>
<p>Expressions describe some computed value. The simplest example would be a literal number like <code>42</code>: an expression that computes the integer value 42.</p>
<p>Some common expressions in Carbon include:</p>
<ul>
<li><p>Literals:</p>
<ul>
<li><a href="#bool">boolean</a>: <code>true</code>, <code>false</code></li>
<li><a href="#integer-literals">integer</a>: <code>42</code>, <code>-7</code></li>
<li><a href="#floating-point-literals">real-number</a>: <code>3.1419</code>, <code>6.022e+23</code></li>
<li><a href="#string-literals">string</a>: <code>"Hello World!"</code></li>
<li><a href="#tuples">tuple</a>: <code>(1, 2, 3)</code></li>
<li><a href="#struct-types">struct</a>: <code>{.word = "the", .count = 56}</code></li>
</ul></li>
<li><p><a href="#names">Names</a> and <a href="expressions/member_access.html">member access</a></p></li>
<li><p><a href="expressions#operators">Operators</a>:</p>
<ul>
<li><a href="expressions/arithmetic.html">Arithmetic</a>: <code>-x</code>, <code>1 + 2</code>, <code>3 - 4</code>, <code>2 * 5</code>, <code>6 / 3</code>, <code>5 % 3</code></li>
<li><a href="expressions/bitwise.html">Bitwise</a>: <code>2 &amp; 3</code>, <code>2 | 4</code>, <code>3 ^ 1</code>, <code>^7</code></li>
<li><a href="expressions/bitwise.html">Bit shift</a>: <code>1 &lt;&lt; 3</code>, <code>8 &gt;&gt; 1</code></li>
<li><a href="expressions/comparison_operators.html">Comparison</a>: <code>2 == 2</code>, <code>3 != 4</code>, <code>5 &lt; 6</code>, <code>7 &gt; 6</code>, <code>8 &lt;= 8</code>, <code>8 &gt;= 8</code></li>
<li><a href="expressions/as_expressions.html">Conversion</a>: <code>2 as i32</code></li>
<li><a href="expressions/logical_operators.html">Logical</a>: <code>a and b</code>, <code>c or d</code>, <code>not e</code></li>
<li><a href="#arrays-and-slices">Indexing</a>: <code>a[3]</code></li>
<li><a href="#functions">Function</a> call: <code>f(4)</code></li>
<li><a href="#pointer-types">Pointer</a>: <code>*p</code>, <code>p-&gt;m</code>, <code>&amp;x</code></li>
<li><a href="#move">Move</a>: <code>~x</code></li>
</ul></li>
<li><p><a href="expressions/if.html">Conditionals</a>: <code>if c then t else f</code></p></li>
<li><p>Parentheses: <code>(7 + 8) * (3 - 1)</code></p></li>
</ul>
<p>When an expression appears in a context in which an expression of a specific type is expected, <a href="expressions/implicit_conversions.html">implicit conversions</a> are applied to convert the expression to the target type.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="expressions/">Expressions</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/162">#162: Basic Syntax</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/555">#555: Operator precedence</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/601">#601: Operator tokens</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/680">#680: And, or, not</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/702">#702: Comparison operators</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/845">#845: as expressions</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/911">#911: Conditional expressions</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/1083">#1083: Arithmetic expressions</a></li>
</ul>
</blockquote>
<h2 id="declarations-definitions-and-scopes">Declarations, Definitions, and Scopes</h2>
<p><em>Declarations</em> introduce a new <a href="#names">name</a> and say what that name represents. For some kinds of entities, like <a href="#functions">functions</a>, there are two kinds of declarations: <em>forward declarations</em> and <em>definitions</em>. For those entities, there should be exactly one definition for the name, and at most one additional forward declaration that introduces the name before it is defined, plus any number of declarations in a <a href="generics/details.html#prioritization-rule"><code>match_first</code> block</a>. Forward declarations can be used to separate interface from implementation, such as to declare a name in an <a href="#files-libraries-packages">api file</a> that is defined in an <a href="#files-libraries-packages">impl file</a>. Forward declarations also allow entities to be used before they are defined, such as to allow cyclic references. A name that has been declared but not defined is called <em>incomplete</em>, and in some cases there are limitations on what can be done with an incomplete name. Within a definition, the defined name is incomplete until the end of the definition is reached, but is complete in the bodies of member functions because they are <a href="#class-functions-and-factory-functions">parsed as if they appeared after the definition</a>.</p>
<p>A name is valid until the end of the innermost enclosing <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)"><em>scope</em></a>. There are a few kinds of scopes:</p>
<ul>
<li>the outermost scope, which includes the whole file,</li>
<li>scopes that are enclosed in curly braces (<code>{</code>...<code>}</code>), and</li>
<li>scopes that encompass a single declaration.</li>
</ul>
<p>For example, the names of the parameters of a <a href="#functions">function</a> or <a href="#classes">class</a> are valid until the end of the declaration. The name of the function or class itself is visible until the end of the enclosing scope.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/project/principles/information_accumulation.md">Principle: Information accumulation</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/875">#875: Principle: information accumulation</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/472">#472: Open question: Calling functions defined later in the same file</a></li>
</ul>
</blockquote>
<h2 id="patterns">Patterns</h2>
<p>A <em>pattern</em> says how to receive some data that is being matched against. There are two kinds of patterns:</p>
<ul>
<li><em>Refutable</em> patterns can fail to match based on the runtime value being matched.</li>
<li><em>Irrefutable</em> patterns are guaranteed to match, so long as the code type-checks.</li>
</ul>
<p>Irrefutable patterns are used in <a href="#functions">function parameters</a>, <a href="#variable-var-declarations">variable <code>var</code> declarations</a>, and <a href="#constant-let-declarations">constant <code>let</code> declarations</a>. <a href="#match"><code>match</code> statements</a> can include both refutable patterns and irrefutable patterns.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="pattern_matching.html">Pattern matching</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/162">#162: Basic Syntax</a></li>
</ul>
</blockquote>
<h3 id="binding-patterns">Binding patterns</h3>
<p>The most common irrefutable pattern is a <em>binding pattern</em>, consisting of a new name, a colon (<code>:</code>), and a type. It binds the matched value of that type to that name. It can only match values that may be <a href="expressions/implicit_conversions.html">implicitly converted</a> to that type. A underscore (<code>_</code>) may be used instead of the name to match a value but without binding any name to it.</p>
<p>Binding patterns default to <em><code>let</code> bindings</em>. The <code>var</code> keyword is used to make it a <em><code>var</code> binding</em>.</p>
<ul>
<li>The result of a <code>let</code> binding is the name is bound to an <a href="#value-categories-and-value-phases">r-value</a>. This means the value cannot be modified, and its address generally cannot be taken.</li>
<li>A <code>var</code> binding has dedicated storage, and so the name is an <a href="#value-categories-and-value-phases">l-value</a> which can be modified and has a stable address.</li>
</ul>
<p>A <code>let</code>-binding may trigger a copy of the original value, or a move if the original value is a temporary, or the binding may be a pointer to the original value, like a <a href="https://en.wikipedia.org/wiki/Reference_(C%2B%2B)"><code>const</code> reference in C++</a>. Which option must not be observable to the programmer. For example, Carbon will not allow modifications to the original value when it is through a pointer. This choice may also be influenced by the type. For example, types that don't support being copied will be passed by pointer instead.</p>
<p>A <a href="#checked-and-template-parameters">generic binding</a> uses <code>:!</code> instead of a colon (<code>:</code>) and can only match <a href="#value-categories-and-value-phases">constant or symbolic values</a>, not run-time values.</p>
<p>The keyword <code>auto</code> may be used in place of the type in a binding pattern, as long as the type can be deduced from the type of a value in the same declaration.</p>
<h3 id="destructuring-patterns">Destructuring patterns</h3>
<p>There are also irrefutable <em>destructuring patterns</em>, such as <em>tuple destructuring</em>. A tuple destructuring pattern looks like a tuple of patterns. It may only be used to match tuple values whose components match the component patterns of the tuple. An example use is:</p>
<pre class="carbon"><code>// `Bar()` returns a tuple consisting of an
// `i32` value and 2-tuple of `f32` values.
fn Bar() -&gt; (i32, (f32, f32));

fn Foo() -&gt; i64 {
  // Pattern in `var` declaration:
  var (p: i64, _: auto) = Bar();
  return p;
}</code></pre>
<p>The pattern used in the <code>var</code> declaration destructures the tuple value returned by <code>Bar()</code>. The first component pattern, <code>p: i64</code>, corresponds to the first component of the value returned by <code>Bar()</code>, which has type <code>i32</code>. This is allowed since there is an implicit conversion from <code>i32</code> to <code>i64</code>. The result of this conversion is assigned to the name <code>p</code>. The second component pattern, <code>_: auto</code>, matches the second component of the value returned by <code>Bar()</code>, which has type <code>(f32, f32)</code>.</p>
<h3 id="refutable-patterns">Refutable patterns</h3>
<p>Additional kinds of patterns are allowed in <a href="#match"><code>match</code> statements</a>, that may or may not match based on the runtime value of the <code>match</code> expression:</p>
<ul>
<li>An <em>expression pattern</em> is an expression, such as <code>42</code>, whose value must be equal to match.</li>
<li>A <em>choice pattern</em> matches one case from a choice type, as described in <a href="#choice-types">the choice types section</a>.</li>
<li>A <em>dynamic cast pattern</em> is tests the dynamic type, as described in <a href="#inheritance">inheritance</a>.</li>
</ul>
<p>See <a href="#match"><code>match</code></a> for examples of refutable patterns.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="pattern_matching.html">Pattern matching</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/1283">#1283: how should pattern matching and implicit conversion interact?</a></li>
</ul>
</blockquote>
<h2 id="name-binding-declarations">Name-binding declarations</h2>
<p>There are two kinds of name-binding declarations:</p>
<ul>
<li>constant declarations, introduced with <code>let</code>, and</li>
<li>variable declarations, introduced with <code>var</code>.</li>
</ul>
<p>There are no forward declarations of these; all name-binding declarations are <a href="#declarations-definitions-and-scopes">definitions</a>.</p>
<h3 id="constant-let-declarations">Constant <code>let</code> declarations</h3>
<p>A <code>let</code> declaration matches an <a href="#patterns">irrefutable pattern</a> to a value. In this example, the name <code>x</code> is bound to the value <code>42</code> with type <code>i64</code>:</p>
<pre class="carbon"><code>let x: i64 = 42;</code></pre>
<p>Here <code>x: i64</code> is the pattern, which is followed by an equal sign (<code>=</code>) and the value to match, <code>42</code>. The names from <a href="#binding-patterns">binding patterns</a> are introduced into the enclosing <a href="#declarations-definitions-and-scopes">scope</a>.</p>
<h3 id="variable-var-declarations">Variable <code>var</code> declarations</h3>
<p>A <code>var</code> declaration is similar, except with <code>var</code> bindings, so <code>x</code> here is an <a href="#value-categories-and-value-phases">l-value</a> with storage and an address, and so may be modified:</p>
<pre class="carbon"><code>var x: i64 = 42;
x = 7;</code></pre>
<p>Variables with a type that has <a href="#unformed-state">an unformed state</a> do not need to be initialized in the variable declaration, but do need to be assigned before they are used.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="variables.html">Variables</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/162">#162: Basic Syntax</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/257">#257: Initialization of memory and variables</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/339">#339: Add <code>var &lt;type&gt; &lt;identifier&gt; [ = &lt;value&gt; ];</code> syntax for variables</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/618">#618: var ordering</a></li>
</ul>
</blockquote>
<h3 id="auto"><code>auto</code></h3>
<p>If <code>auto</code> is used as the type in a <code>var</code> or <code>let</code> declaration, the type is the static type of the initializer expression, which is required.</p>
<pre><code>var x: i64 = 2;
// The type of `y` is inferred to be `i64`.
let y: auto = x + 3;
// The type of `z` is inferred to be `bool`.
var z: auto = (y &gt; 1);</code></pre>
<blockquote>
<p>References:</p>
<ul>
<li><a href="type_inference.html">Type inference</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/851">#851: auto keyword for vars</a></li>
</ul>
</blockquote>
<h2 id="functions">Functions</h2>
<p>Functions are the core unit of behavior. For example, this is a <a href="#declarations-definitions-and-scopes">forward declaration</a> of a function that adds two 64-bit integers:</p>
<pre class="carbon"><code>fn Add(a: i64, b: i64) -&gt; i64;</code></pre>
<p>Breaking this apart:</p>
<ul>
<li><code>fn</code> is the keyword used to introduce a function.</li>
<li>Its name is <code>Add</code>. This is the name added to the enclosing <a href="#declarations-definitions-and-scopes">scope</a>.</li>
<li>The <a href="#parameters">parameter list</a> in parentheses (<code>(</code>...<code>)</code>) is a comma-separated list of <a href="#patterns">irrefutable patterns</a>.</li>
<li>It returns an <code>i64</code> result. Functions that return nothing omit the <code>-&gt;</code> and return type.</li>
</ul>
<p>You would call this function like <code>Add(1, 2)</code>.</p>
<p>A function definition is a function declaration that has a body <a href="#blocks-and-statements">block</a> instead of a semicolon:</p>
<pre class="carbon"><code>fn Add(a: i64, b: i64) -&gt; i64 {
  return a + b;
}</code></pre>
<p>The names of the parameters are in scope until the end of the definition or declaration. The parameter names in a forward declaration may be omitted using <code>_</code>, but must match the definition if they are specified.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="functions.html">Functions</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/162">#162: Basic Syntax</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/438">#438: Add statement syntax for function declarations</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/476">#476: Optional argument names (unused arguments)</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/1132">#1132: How do we match forward declarations with their definitions?</a></li>
</ul>
</blockquote>
<h3 id="parameters">Parameters</h3>
<p>The bindings in the parameter list default to <a href="#binding-patterns"><code>let</code> bindings</a>, and so the parameter names are treated as <a href="#value-categories-and-value-phases">r-values</a>. This is appropriate for input parameters. This binding will be implemented using a pointer, unless it is legal to copy and copying is cheaper.</p>
<p>If the <code>var</code> keyword is added before the binding, then the arguments will be copied (or moved from a temporary) to new storage, and so can be mutated in the function body. The copy ensures that any mutations will not be visible to the caller.</p>
<p>Use a <a href="#pointer-types">pointer</a> parameter type to represent an <a href="https://en.wikipedia.org/wiki/Parameter_(computer_programming)#Output_parameters">input/output parameter</a>, allowing a function to modify a variable of the caller's. This makes the possibility of those modifications visible: by taking the address using <code>&amp;</code> in the caller, and dereferencing using <code>*</code> in the callee.</p>
<p>Outputs of a function should prefer to be returned. Multiple values may be returned using a <a href="#tuples">tuple</a> or <a href="#struct-types">struct</a> type.</p>
<h3 id="auto-return-type"><code>auto</code> return type</h3>
<p>If <code>auto</code> is used in place of the return type, the return type of the function is inferred from the function body. It is set to <a href="#common-type">common type</a> of the static type of arguments to the <a href="#return"><code>return</code> statements</a> in the function. This is not allowed in a forward declaration.</p>
<pre><code>// Return type is inferred to be `bool`, the type of `a &gt; 0`.
fn Positive(a: i64) -&gt; auto {
  return a &gt; 0;
}</code></pre>
<blockquote>
<p>References:</p>
<ul>
<li><a href="type_inference.html">Type inference</a></li>
<li><a href="functions.html#return-clause">Function return clause</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/826">#826: Function return type inference</a></li>
</ul>
</blockquote>
<h3 id="blocks-and-statements">Blocks and statements</h3>
<p>A <em>block</em> is a sequence of <em>statements</em>. A block defines a <a href="#declarations-definitions-and-scopes">scope</a> and, like other scopes, is enclosed in curly braces (<code>{</code>...<code>}</code>). Each statement is terminated by a semicolon or block. <a href="#expressions">Expressions</a> and <a href="#variable-var-declarations"><code>var</code></a> and <a href="#constant-let-declarations"><code>let</code></a> are valid statements.</p>
<p>Statements within a block are normally executed in the order they appear in the source code, except when modified by control-flow statements.</p>
<p>The body of a function is defined by a block, and some <a href="#control-flow">control-flow statements</a> have their own blocks of code. These are nested within the enclosing scope. For example, here is a function definition with a block of statements defining the body of the function, and a nested block as part of a <code>while</code> statement:</p>
<pre class="carbon"><code>fn Foo() {
  Bar();
  while (Baz()) {
    Quux();
  }
}</code></pre>
<blockquote>
<p>References:</p>
<ul>
<li><a href="blocks_and_statements.html">Blocks and statements</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/162">#162: Basic Syntax</a></li>
</ul>
</blockquote>
<h3 id="assignment-statements">Assignment statements</h3>
<p>Assignment statements mutate the value of the <a href="#value-categories-and-value-phases">l-value</a> described on the left-hand side of the assignment.</p>
<ul>
<li>Assignment: <code>x = y;</code>. <code>x</code> is assigned the value of <code>y</code>.</li>
<li>Increment and decrement: <code>++i;</code>, <code>--j;</code>. <code>i</code> is set to <code>i + 1</code>, <code>j</code> is set to <code>j - 1</code>.</li>
<li>Compound assignment: <code>x += y;</code>, <code>x -= y;</code>, <code>x *= y;</code>, <code>x /= y;</code>, <code>x &amp;= y;</code>, <code>x |= y;</code>, <code>x ^= y;</code>, <code>x &lt;&lt;= y;</code>, <code>x &gt;&gt;= y;</code>. <code>x @= y;</code> is equivalent to <code>x = x @ y;</code> for each operator <code>@</code>.</li>
</ul>
<p>Unlike C++, these assignments are statements, not expressions, and don't return a value.</p>
<h3 id="control-flow">Control flow</h3>
<p>Blocks of statements are generally executed sequentially. Control-flow statements give additional control over the flow of execution and which statements are executed.</p>
<p>Some control-flow statements include <a href="#blocks-and-statements">blocks</a>. Those blocks will always be within curly braces <code>{</code>...<code>}</code>.</p>
<pre class="carbon"><code>// Curly braces { ... } are required.
if (condition) {
  ExecutedWhenTrue();
} else {
  ExecutedWhenFalse();
}</code></pre>
<p>This is unlike C++, which allows control-flow constructs to omit curly braces around a single statement.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="control_flow/index.html">Control flow</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/162">#162: Basic Syntax</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/623">#623: Require braces</a></li>
</ul>
</blockquote>
<h4 id="if-and-else"><code>if</code> and <code>else</code></h4>
<p><code>if</code> and <code>else</code> provide conditional execution of statements. An <code>if</code> statement consists of:</p>
<ul>
<li>An <code>if</code> introducer followed by a condition in parentheses. If the condition evaluates to <code>true</code>, the block following the condition is executed, otherwise it is skipped.</li>
<li>This may be followed by zero or more <code>else if</code> clauses, whose conditions are evaluated if all prior conditions evaluate to <code>false</code>, with a block that is executed if that evaluation is to <code>true</code>.</li>
<li>A final optional <code>else</code> clause, with a block that is executed if all conditions evaluate to <code>false</code>.</li>
</ul>
<p>For example:</p>
<pre class="carbon"><code>if (fruit.IsYellow()) {
  Console.Print(&quot;Banana!&quot;);
} else if (fruit.IsOrange()) {
  Console.Print(&quot;Orange!&quot;);
} else {
  Console.Print(&quot;Vegetable!&quot;);
}</code></pre>
<p>This code will:</p>
<ul>
<li>Print <code>Banana!</code> if <code>fruit.IsYellow()</code> is <code>true</code>.</li>
<li>Print <code>Orange!</code> if <code>fruit.IsYellow()</code> is <code>false</code> and <code>fruit.IsOrange()</code> is <code>true</code>.</li>
<li>Print <code>Vegetable!</code> if both of the above return <code>false</code>.</li>
</ul>
<blockquote>
<p>References:</p>
<ul>
<li><a href="control_flow/conditionals.html">Control flow</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/285">#285: if/else</a></li>
</ul>
</blockquote>
<h4 id="loops">Loops</h4>
<blockquote>
<p>References: <a href="control_flow/loops.html">Loops</a></p>
</blockquote>
<h5 id="while"><code>while</code></h5>
<p><code>while</code> statements loop for as long as the passed expression returns <code>true</code>. For example, this prints <code>0</code>, <code>1</code>, <code>2</code>, then <code>Done!</code>:</p>
<pre class="carbon"><code>var x: i32 = 0;
while (x &lt; 3) {
  Console.Print(x);
  ++x;
}
Console.Print(&quot;Done!&quot;);</code></pre>
<blockquote>
<p>References:</p>
<ul>
<li><a href="control_flow/loops.html#while"><code>while</code> loops</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/340">#340: Add C++-like <code>while</code> loops</a></li>
</ul>
</blockquote>
<h5 id="for"><code>for</code></h5>
<p><code>for</code> statements support range-based looping, typically over containers. For example, this prints each <code>String</code> value in <code>names</code>:</p>
<pre class="carbon"><code>for (var name: String in names) {
  Console.Print(name);
}</code></pre>
<blockquote>
<p>References:</p>
<ul>
<li><a href="control_flow/loops.html#for"><code>for</code> loops</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/353">#353: Add C++-like <code>for</code> loops</a></li>
</ul>
</blockquote>
<h5 id="break"><code>break</code></h5>
<p>The <code>break</code> statement immediately ends a <code>while</code> or <code>for</code> loop. Execution will continue starting from the end of the loop's scope. For example, this processes steps until a manual step is hit (if no manual step is hit, all steps are processed):</p>
<pre class="carbon"><code>for (var step: Step in steps) {
  if (step.IsManual()) {
    Console.Print(&quot;Reached manual step!&quot;);
    break;
  }
  step.Process();
}</code></pre>
<blockquote>
<p>References: <a href="control_flow/loops.html#break"><code>break</code></a></p>
</blockquote>
<h5 id="continue"><code>continue</code></h5>
<p>The <code>continue</code> statement immediately goes to the next loop of a <code>while</code> or <code>for</code>. In a <code>while</code>, execution continues with the <code>while</code> expression. For example, this prints all non-empty lines of a file, using <code>continue</code> to skip empty lines:</p>
<pre class="carbon"><code>var f: File = OpenFile(path);
while (!f.EOF()) {
  var line: String = f.ReadLine();
  if (line.IsEmpty()) {
    continue;
  }
  Console.Print(line);
}</code></pre>
<blockquote>
<p>References: <a href="control_flow/loops.html#continue"><code>continue</code></a></p>
</blockquote>
<h4 id="return"><code>return</code></h4>
<p>The <code>return</code> statement ends the flow of execution within a function, returning execution to the caller.</p>
<pre class="carbon"><code>// Prints the integers 1 .. `n` and then
// returns to the caller.
fn PrintFirstN(n: i32) {
  var i: i32 = 0;
  while (true) {
    i += 1;
    if (i &gt; n) {
      // None of the rest of the function is
      // executed after a `return`.
      return;
    }
    Console.Print(i);
  }
}</code></pre>
<p>If the function returns a value to the caller, that value is provided by an expression in the return statement. For example:</p>
<pre class="carbon"><code>fn Sign(i: i32) -&gt; i32 {
  if (i &gt; 0) {
    return 1;
  }
  if (i &lt; 0) {
    return -1;
  }
  return 0;
}

Assert(Sign(-3) == -1);</code></pre>
<blockquote>
<p>References:</p>
<ul>
<li><a href="control_flow/return.html"><code>return</code></a></li>
<li><a href="functions.html#return-statements"><code>return</code> statements</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/415">#415: return</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/538">#538: return with no argument</a></li>
</ul>
</blockquote>
<h5 id="returned-var"><code>returned var</code></h5>
<p>To avoid a copy when returning a variable, add a <code>returned</code> prefix to the variable's declaration and use <code>return var</code> instead of returning an expression, as in:</p>
<pre class="carbon"><code>fn MakeCircle(radius: i32) -&gt; Circle {
  returned var c: Circle;
  c.radius = radius;
  // `return c` would be invalid because `returned` is in use.
  return var;
}</code></pre>
<p>This is instead of <a href="https://en.wikipedia.org/wiki/Copy_elision#Return_value_optimization">the "named return value optimization" of C++</a>.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="control_flow/return.html#returned-var"><code>returned var</code></a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/257">#257: Initialization of memory and variables</a></li>
</ul>
</blockquote>
<h4 id="match"><code>match</code></h4>
<p><code>match</code> is a control flow similar to <code>switch</code> of C and C++ and mirrors similar constructs in other languages, such as Swift. The <code>match</code> keyword is followed by an expression in parentheses, whose value is matched against the <code>case</code> declarations, each of which contains a <a href="#refutable-patterns">refutable pattern</a>, in order. The refutable pattern may optionally be followed by an <code>if</code> expression, which may use the names from bindings in the pattern.</p>
<p>The code for the first matching <code>case</code> is executed. An optional <code>default</code> block may be placed after the <code>case</code> declarations, it will be executed if none of the <code>case</code> declarations match.</p>
<p>An example <code>match</code> is:</p>
<pre class="carbon"><code>fn Bar() -&gt; (i32, (f32, f32));

fn Foo() -&gt; f32 {
  match (Bar()) {
    case (42, (x: f32, y: f32)) =&gt; {
      return x - y;
    }
    case (p: i32, (x: f32, _: f32)) if (p &lt; 13) =&gt; {
      return p * x;
    }
    case (p: i32, _: auto) if (p &gt; 3) =&gt; {
      return p * Pi;
    }
    default =&gt; {
      return Pi;
    }
  }
}</code></pre>
<blockquote>
<p>References:</p>
<ul>
<li><a href="pattern_matching.html">Pattern matching</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/1283">#1283: how should pattern matching and implicit conversion interact?</a></li>
</ul>
</blockquote>
<h2 id="user-defined-types">User-defined types</h2>
<blockquote>
<p><strong>TODO:</strong> Maybe rename to "nominal types"?</p>
</blockquote>
<h3 id="classes">Classes</h3>
<p><em>Nominal classes</em>, or just <a href="https://en.wikipedia.org/wiki/Class_(computer_programming)"><em>classes</em></a>, are a way for users to define their own <a href="https://en.wikipedia.org/wiki/Data_structure">data structures</a> or <a href="https://en.wikipedia.org/wiki/Record_(computer_science)">record types</a>.</p>
<p>This is an example of a class <a href="#declarations-definitions-and-scopes">definition</a>:</p>
<pre class="carbon"><code>class Widget {
  var x: i32;
  var y: i32;
  var payload: String;
}</code></pre>
<p>Breaking this apart:</p>
<ul>
<li>This defines a class named <code>Widget</code>. <code>Widget</code> is the name added to the enclosing <a href="#declarations-definitions-and-scopes">scope</a>.</li>
<li>The name <code>Widget</code> is followed by curly braces (<code>{</code>...<code>}</code>) containing the class <em>body</em>, making this a <a href="#declarations-definitions-and-scopes">definition</a>. A <a href="#declarations-definitions-and-scopes">forward declaration</a> would instead have a semicolon(<code>;</code>).</li>
<li>Those braces delimit the class' <a href="#declarations-definitions-and-scopes">scope</a>.</li>
<li>Fields, or <a href="https://en.wikipedia.org/wiki/Instance_variable">instances variables</a>, are defined using <a href="#variable-var-declarations"><code>var</code> declarations</a>. <code>Widget</code> has two <code>i32</code> fields (<code>x</code> and <code>y</code>), and one <code>String</code> field (<code>payload</code>).</li>
</ul>
<p>The order of the field declarations determines the fields' memory-layout order.</p>
<p>Classes may have other kinds of members beyond fields declared in its scope:</p>
<ul>
<li><a href="#class-functions-and-factory-functions">Class functions</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#aliases"><code>alias</code></a></li>
<li><a href="#constant-let-declarations"><code>let</code></a> to define class constants. <strong>TODO:</strong> Another syntax to define constants associated with the class like <code>class let</code> or <code>static let</code>?</li>
<li><code>class</code>, to define a <a href="https://en.wikipedia.org/wiki/Inner_class"><em>member class</em> or <em>nested class</em></a></li>
</ul>
<p>Within the scope of a class, the unqualified name <code>Self</code> can be used to refer to the class itself.</p>
<p>Members of a class are <a href="expressions/member_access.html">accessed</a> using the dot (<code>.</code>) notation, so given an instance <code>dial</code> of type <code>Widget</code>, <code>dial.payload</code> refers to its <code>payload</code> field.</p>
<p>Both <a href="#struct-types">structural data classes</a> and nominal classes are considered <em>class types</em>, but they are commonly referred to as "structs" and "classes" respectively when that is not confusing. Like structs, classes refer to their members by name. Unlike structs, classes are <a href="https://en.wikipedia.org/wiki/Nominal_type_system#Nominal_typing">nominal types</a>.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="classes.html#nominal-class-types">Classes</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/722">#722: Nominal classes and methods</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/989">#989: Member access expressions</a></li>
</ul>
</blockquote>
<h4 id="assignment">Assignment</h4>
<p>There is an <a href="expressions/implicit_conversions.html">implicit conversions</a> defined between a <a href="#struct-types">struct literal</a> and a class type with the same fields, in any scope that has <a href="#access-control">access</a> to all of the class' fields. This may be used to assign or initialize a variable with a class type, as in:</p>
<pre class="carbon"><code>var sprocket: Widget = {.x = 3, .y = 4, .payload = &quot;Sproing&quot;};
sprocket = {.x = 2, .y = 1, .payload = &quot;Bounce&quot;};</code></pre>
<blockquote>
<p>References:</p>
<ul>
<li><a href="classes.html#construction">Classes: Construction</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/981">#981: Implicit conversions for aggregates</a></li>
</ul>
</blockquote>
<h4 id="class-functions-and-factory-functions">Class functions and factory functions</h4>
<p>Classes may also contain <em>class functions</em>. These are functions that are accessed as members of the type, like <a href="https://en.wikipedia.org/wiki/Method_(computer_programming)#Static_methods">static member functions in C++</a>, as opposed to <a href="#methods">methods</a> that are members of instances. They are commonly used to define a function that creates instances. Carbon does not have separate <a href="https://en.wikipedia.org/wiki/Constructor_(object-oriented_programming)">constructors</a> like C++ does.</p>
<pre class="carbon"><code>class Point {
  // Class function that instantiates `Point`.
  // `Self` in class scope means the class currently being defined.
  fn Origin() -&gt; Self {
    return {.x = 0, .y = 0};
  }
  var x: i32;
  var y: i32;
}</code></pre>
<p>Note that if the definition of a function is provided inside the class scope, the body is treated as if it was defined immediately after the outermost class definition. This means that members such as the fields will be considered declared even if their declarations are later in the source than the class function.</p>
<p>The <a href="#returned-var"><code>returned var</code> feature</a> can be used if the address of the instance being created is needed in a factory function, as in:</p>
<pre class="carbon"><code>class Registered {
  fn Create() -&gt; Self {
    returned var result: Self = {...};
    StoreMyPointerSomewhere(&amp;result);
    return var;
  }
}</code></pre>
<p>This approach can also be used for types that can't be copied or moved.</p>
<h4 id="methods">Methods</h4>
<p>Class type definitions can include methods:</p>
<pre class="carbon"><code>class Point {
  // Method defined inline
  fn Distance[me: Self](x2: i32, y2: i32) -&gt; f32 {
    var dx: i32 = x2 - me.x;
    var dy: i32 = y2 - me.y;
    return Math.Sqrt(dx * dx - dy * dy);
  }
  // Mutating method declaration
  fn Offset[addr me: Self*](dx: i32, dy: i32);

  var x: i32;
  var y: i32;
}

// Out-of-line definition of method declared inline
fn Point.Offset[addr me: Self*](dx: i32, dy: i32) {
  me-&gt;x += dx;
  me-&gt;y += dy;
}

var origin: Point = {.x = 0, .y = 0};
Assert(Math.Abs(origin.Distance(3, 4) - 5.0) &lt; 0.001);
origin.Offset(3, 4);
Assert(origin.Distance(3, 4) == 0.0);</code></pre>
<p>This defines a <code>Point</code> class type with two integer data members <code>x</code> and <code>y</code> and two methods <code>Distance</code> and <code>Offset</code>:</p>
<ul>
<li>Methods are defined as class functions with a <code>me</code> parameter inside square brackets <code>[</code>...<code>]</code> before the regular explicit parameter list in parens <code>(</code>...<code>)</code>.</li>
<li>Methods are called using using the member syntax, <code>origin.Distance(</code>...<code>)</code> and <code>origin.Offset(</code>...<code>)</code>.</li>
<li><code>Distance</code> computes and returns the distance to another point, without modifying the <code>Point</code>. This is signified using <code>[me: Self]</code> in the method declaration.</li>
<li><code>origin.Offset(</code>...<code>)</code> does modify the value of <code>origin</code>. This is signified using <code>[addr me: Self*]</code> in the method declaration. Since calling this method requires taking the address of <code>origin</code>, it may only be called on <a href="#const">non-<code>const</code></a> <a href="#value-categories-and-value-phases">l-values</a>.</li>
<li>Methods may be declared lexically inline like <code>Distance</code>, or lexically out of line like <code>Offset</code>.</li>
</ul>
<blockquote>
<p>References:</p>
<ul>
<li><a href="classes.html#methods">Methods</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/722">#722: Nominal classes and methods</a></li>
</ul>
</blockquote>
<h4 id="inheritance">Inheritance</h4>
<p>The philosophy of inheritance support in Carbon is to focus on use cases where inheritance is a good match, and use other features for other cases. For example, <a href="#mixins">mixins</a> for implementation reuse and <a href="#generics">generics</a> for separating interface from implementation. This allows Carbon to move away from <a href="https://en.wikipedia.org/wiki/Multiple_inheritance">multiple inheritance</a>, which doesn't have as efficient of an implementation strategy.</p>
<p>Classes by default are <a href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)#Non-subclassable_classes"><em>final</em></a>, which means they may not be extended. A class may be declared as allowing extension using either the <code>base class</code> or <code>abstract class</code> introducer instead of <code>class</code>. An <code>abstract class</code> is a base class that may not itself be instantiated.</p>
<pre class="carbon"><code>base class MyBaseClass { ... }</code></pre>
<p>Either kind of base class may be <em>extended</em> to get a <em>derived class</em>. Derived classes are final unless they are themselved declared <code>base</code> or <code>abstract</code>. Classes may only extend a single class. Carbon only supports single inheritance, and will use mixins instead of multiple inheritance.</p>
<pre class="carbon"><code>base class MiddleDerived extends MyBaseClass { ... }
class FinalDerived extends MiddleDerived { ... }
// ❌ Forbidden: class Illegal extends FinalDerived { ... }</code></pre>
<p>A base class may define <a href="https://en.wikipedia.org/wiki/Virtual_function">virtual methods</a>. These are methods whose implementation may be overridden in a derived class. By default methods are <em>non-virtual</em>, the declaration of a virtual method must be prefixed by one of these three keywords:</p>
<ul>
<li>A method marked <code>virtual</code> has a definition in this class but not in any base.</li>
<li>A method marked <code>abstract</code> does not have have a definition in this class, but must have a definition in any non-<code>abstract</code> derived class.</li>
<li>A method marked <code>impl</code> has a definition in this class, overriding any definition in a base class.</li>
</ul>
<p>A pointer to a derived class may be cast to a pointer to one of its base classes. Calling a virtual method through a pointer to a base class will use the overridden definition provided in the derived class. Base classes with <code>virtual</code> methods may use <a href="https://en.wikipedia.org/wiki/Run-time_type_information">run-time type information</a> in a match statement to dynamically test whether the dynamic type of a value is some derived class, as in:</p>
<pre class="carbon"><code>var base_ptr: MyBaseType* = ...;
match (base_ptr) {
  case dyn p: MiddleDerived* =&gt; { ... }
}</code></pre>
<p>For purposes of construction, a derived class acts like its first field is called <code>base</code> with the type of its immediate base class.</p>
<pre class="carbon"><code>class MyDerivedType extends MyBaseType {
  fn Create() -&gt; MyDerivedType {
    return {.base = MyBaseType.Create(), .derived_field = 7};
  }
  var derived_field: i32;
}</code></pre>
<p>Abstract classes can't be instantiated, so instead they should define class functions returning <code>partial Self</code>. Those functions should be marked <a href="#access-control"><code>protected</code></a> so they may only be used by derived classes.</p>
<pre class="carbon"><code>abstract class AbstractClass {
  protected fn Create() -&gt; partial Self {
    return {.field_1 = 3, .field_2 = 9};
  }
  // ...
  var field_1: i32;
  var field_2: i32;
}
// ❌ Error: can&#39;t instantiate abstract class
var abc: AbstractClass = ...;

class DerivedFromAbstract extends AbstractClass {
  fn Create() -&gt; Self {
    // AbstractClass.Create() returns a
    // `partial AbstractClass` that can be used as
    // the `.base` member when constructing a value
    // of a derived class.
    return {.base = AbstractClass.Create(),
            .derived_field = 42 };
  }

  var derived_field: i32;
}</code></pre>
<blockquote>
<p>References:</p>
<ul>
<li><a href="classes.html#inheritance">Inheritance</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/777">#777: Inheritance</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/820">#820: Implicit conversions</a></li>
</ul>
</blockquote>
<h4 id="access-control">Access control</h4>
<p>Class members are by default publicly accessible. The <code>private</code> keyword prefix can be added to the member's declaration to restrict it to members of the class or any friends. A <code>private virtual</code> or <code>private abstract</code> method may be implemented in derived classes, even though it may not be called.</p>
<p>Friends may be declared using a <code>friend</code> declaration inside the class naming an existing function or type. Unlike C++, <code>friend</code> declarations may only refer to names resolvable by the compiler, and don't act like forward declarations.</p>
<p><code>protected</code> is like <code>private</code>, but also gives access to derived classes.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="classes.html#access-control">Access control for class members</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/665">#665: <code>private</code> vs <code>public</code> <em>syntax</em> strategy, as well as other visibility tools like <code>external</code>/<code>api</code>/etc.</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/971">#971: Private interfaces in public API files</a></li>
</ul>
</blockquote>
<h4 id="destructors">Destructors</h4>
<p>A destructor for a class is custom code executed when the lifetime of a value of that type ends. They are defined with the <code>destructor</code> keyword followed by either <code>[me: Self]</code> or <code>[addr me: Self*]</code> (as is done with <a href="#methods">methods</a>) and the block of code in the class definition, as in:</p>
<pre class="carbon"><code>class MyClass {
  destructor [me: Self] { ... }
}</code></pre>
<p>or:</p>
<pre class="carbon"><code>class MyClass {
  // Can modify `me` in the body.
  destructor [addr me: Self*] { ... }
}</code></pre>
<p>The destructor for a class is run before the destructors of its data members. The data members are destroyed in reverse order of declaration. Derived classes are destroyed before their base classes.</p>
<p>A destructor in an abstract or base class may be declared <code>virtual</code> like with <a href="#inheritance">methods</a>. Destructors in classes derived from one with a virtual destructor must be declared with the <code>impl</code> keyword prefix. It is illegal to delete an instance of a derived class through a pointer to a base class unless the base class is declared <code>virtual</code> or <code>impl</code>. To delete a pointer to a non-abstract base class when it is known not to point to a value with a derived type, use <code>UnsafeDelete</code>.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="classes.html#destructors">Destructors</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/1154">#1154: Destructors</a></li>
</ul>
</blockquote>
<h4 id="const"><code>const</code></h4>
<p><strong>Note:</strong> This is provisional, no design for <code>const</code> has been through the proposal process yet.</p>
<p>For every type <code>MyClass</code>, there is the type <code>const MyClass</code> such that:</p>
<ul>
<li>The data representation is the same, so a <code>MyClass*</code> value may be implicitly converted to a <code>(const MyClass)*</code>.</li>
<li>A <code>const MyClass</code> <a href="#value-categories-and-value-phases">l-value</a> may automatically convert to a <code>MyClass</code> r-value, the same way that a <code>MyClass</code> l-value can.</li>
<li>If member <code>x</code> of <code>MyClass</code> has type <code>T</code>, then member <code>x</code> of <code>const MyClass</code> has type <code>const T</code>.</li>
<li>The API of a <code>const MyClass</code> is a subset of <code>MyClass</code>, excluding all methods taking <code>[addr me: Self*]</code>.</li>
</ul>
<p>Note that <code>const</code> binds more tightly than postfix-<code>*</code> for forming a pointer type, so <code>const MyClass*</code> is equal to <code>(const MyClass)*</code>.</p>
<p>This example uses the definition of <code>Point</code> from the <a href="#methods">"methods" section</a>:</p>
<pre class="carbon"><code>var origin: Point = {.x = 0, .y = 0};

// ✅ Allowed conversion from `Point*` to
// `const Point*`:
let p: const Point* = &amp;origin;

// ✅ Allowed conversion of `const Point` l-value
// to `Point` r-value.
let five: f32 = p-&gt;Distance(3, 4);

// ❌ Error: mutating method `Offset` excluded
// from `const Point` API.
p-&gt;Offset(3, 4);

// ❌ Error: mutating method `AssignAdd.Op`
// excluded from `const i32` API.
p-&gt;x += 2;</code></pre>
<h4 id="unformed-state">Unformed state</h4>
<p>Types indicate that they support unformed states by <a href="#interfaces-and-implementations">implementing a particular interface</a>, otherwise variables of that type must be explicitly initialized when they are declared.</p>
<p>An unformed state for an object is one that satisfies the following properties:</p>
<ul>
<li>Assignment from a fully formed value is correct using the normal assignment implementation for the type.</li>
<li>Destruction must be correct using the type's normal destruction implementation.</li>
<li>Destruction must be optional. The behavior of the program must be equivalent whether the destructor is run or not for an unformed object, including not leaking resources.</li>
</ul>
<p>A type might have more than one in-memory representation for the unformed state, and those representations may be the same as valid fully formed values for that type. For example, all values are legal representations of the unformed state for any type with a trivial destructor like <code>i32</code>. Types may define additional initialization for the <a href="#build-modes">hardened build mode</a>. For example, this causes integers to be set to <code>0</code> when in unformed state in this mode.</p>
<p>Any operation on an unformed object <em>other</em> than destruction or assignment from a fully formed value is an error, even if its in-memory representation is that of a valid value for that type.</p>
<blockquote>
<p>References:</p>
<ul>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/257">#257: Initialization of memory and variables</a></li>
</ul>
</blockquote>
<h4 id="move">Move</h4>
<p>Carbon will allow types to define if and how they are moved. This can happen when returning a value from a function or by using the <em>move operator</em> <code>~x</code>. This leaves <code>x</code> in an <a href="#unformed-state">unformed state</a> and returns its old value.</p>
<h4 id="mixins">Mixins</h4>
<p>Mixins allow reuse with different trade-offs compared to <a href="#inheritance">inheritance</a>. Mixins focus on implementation reuse, such as might be done using <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a> or <a href="https://en.wikipedia.org/wiki/Multiple_inheritance">multiple inheritance</a> in C++.</p>
<p><strong>TODO:</strong> The design for mixins is still under development.</p>
<h3 id="choice-types">Choice types</h3>
<p>A <em>choice type</em> is a <a href="https://en.wikipedia.org/wiki/Tagged_union">tagged union</a>, that can store different types of data in a storage space that can hold the largest. A choice type has a name, and a list of cases separated by commas (<code>,</code>). Each case has a name and an optional parameter list.</p>
<pre class="carbon"><code>choice IntResult {
  Success(value: i32),
  Failure(error: String),
  Cancelled
}</code></pre>
<p>The value of a choice type is one of the cases, plus the values of the parameters to that case, if any. A value can be constructed by naming the case and providing values for the parameters, if any:</p>
<pre class="carbon"><code>fn ParseAsInt(s: String) -&gt; IntResult {
  var r: i32 = 0;
  for (c: i32 in s) {
    if (not IsDigit(c)) {
      // Equivalent to `IntResult.Failure(...)`
      return .Failure(&quot;Invalid character&quot;);
    }
    // ...
  }
  return .Success(r);
}</code></pre>
<p>Choice type values may be consumed using a <a href="#match"><code>match</code> statement</a>:</p>
<pre class="carbon"><code>match (ParseAsInt(s)) {
  case .Success(value: i32) =&gt; {
    return value;
  }
  case .Failure(error: String) =&gt; {
    Display(error);
  }
  case .Cancelled =&gt; {
    Terminate();
  }
}</code></pre>
<p>They can also represent an <a href="https://en.wikipedia.org/wiki/Enumerated_type">enumerated type</a>, if no additional data is associated with the choices, as in:</p>
<pre class="carbon"><code>choice LikeABoolean { False, True }</code></pre>
<blockquote>
<p>References:</p>
<ul>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/157">#157: Design direction for sum types</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/162">#162: Basic Syntax</a></li>
</ul>
</blockquote>
<h2 id="names">Names</h2>
<p>Names are introduced by <a href="#declarations-definitions-and-scopes">declarations</a> and are valid until the end of the scope in which they appear. Code may not refer to names earlier in the source than they are declared. In executable scopes such as function bodies, names declared later are not found. In declarative scopes such as packages, classes, and interfaces, it is an error to refer to names declared later, except that inline class member function bodies are <a href="#class-functions-and-factory-functions">parsed as if they appeared after the class</a>.</p>
<p>A name in Carbon is formed from a sequence of letters, numbers, and underscores, and starts with a letter. We intend to follow <a href="https://unicode.org/reports/tr31/">Unicode's Annex 31</a> in selecting valid identifier characters, but a concrete set of valid characters has not been selected yet.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="lexical_conventions">Lexical conventions</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/project/principles/information_accumulation.md">Principle: Information accumulation</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/142">#142: Unicode source files</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/472">#472: Open question: Calling functions defined later in the same file</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/875">#875: Principle: information accumulation</a></li>
</ul>
</blockquote>
<h3 id="files-libraries-packages">Files, libraries, packages</h3>
<ul>
<li><strong>Files</strong> are grouped into libraries, which are in turn grouped into packages.</li>
<li><strong>Libraries</strong> are the granularity of code reuse through imports.</li>
<li><strong>Packages</strong> are the unit of distribution.</li>
</ul>
<p>Each library must have exactly one <code>api</code> file. This file includes declarations for all public names of the library. Definitions for those declarations must be in some file in the library, either the <code>api</code> file or an <code>impl</code> file.</p>
<p>Every package has its own namespace. This means libraries within a package need to coordinate to avoid name conflicts, but not across packages.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="code_and_name_organization">Code and name organization</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/107">#107: Code and name organization</a></li>
</ul>
</blockquote>
<h3 id="package-declaration">Package declaration</h3>
<p>Files start with an optional package declaration, consisting of:</p>
<ul>
<li>the <code>package</code> keyword introducer,</li>
<li>an optional identifier specifying the package name,</li>
<li>optional <code>library</code> followed by a string with the library name,</li>
<li>either <code>api</code> or <code>impl</code>, and</li>
<li>a terminating semicolon (<code>;</code>).</li>
</ul>
<p>For example:</p>
<pre class="carbon"><code>// Package name is `Geometry`.
// Library name is &quot;Shapes&quot;.
// This file is an `api` file, not an `impl` file.
package Geometry library &quot;Shapes&quot; api;</code></pre>
<p>Parts of this declaration may be omitted:</p>
<ul>
<li>If the package name is omitted, as in <code>package library "Main" api;</code>, the file contributes to the default package. No other package may import from the default package.</li>
<li>If the library keyword is not specified, as in <code>package Geometry api;</code>, this file contributes to the default library.</li>
<li>If a file has no package declaration at all, it is the <code>api</code> file belonging to the default package and default library. This is particularly for tests and smaller examples. No other library can import this library even from within the default package. It can be split across multiple <code>impl</code> files using a <code>package impl;</code> package declaration.</li>
</ul>
<p>A program need not use the default package, but if it does, it should contain the entry-point function. By default, the entry-point function is <code>Run</code> from the default package.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="code_and_name_organization">Code and name organization</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/107">#107: Code and name organization</a></li>
</ul>
</blockquote>
<h3 id="imports">Imports</h3>
<p>After the package declaration, files may include <code>import</code> declarations. These include the package name and optionally <code>library</code> followed by the library name. If the library is omitted, the default library for that package is imported.</p>
<pre class="carbon"><code>// Import the &quot;Vector&quot; library from the
// `LinearAlgebra` package.
import LinearAlgebra library &quot;Vector&quot;;
// Import the default library from the
// `ArbitraryPrecision` package.
import ArbitraryPrecision;</code></pre>
<p>The syntax <code>import PackageName ...</code> introduces the name <code>PackageName</code> as a <a href="#name-visibility"><code>private</code></a> name naming the given package. It cannot be used to import libraries of the current package. Importing additional libraries from that package makes additional members of <code>PackageName</code> visible.</p>
<p>Libraries from the current package are imported by omitting the package name.</p>
<pre class="carbon"><code>// Import the &quot;Vertex&quot; library from the same package.
import library &quot;Vertex&quot;;
// Import the default library from the same package.
import library default;</code></pre>
<p>The <code>import library ...</code> syntax adds all the public top-level names within the given library to the top-level scope of the current file as <a href="#name-visibility"><code>private</code></a> names, and similarly for names in <a href="#namespaces">namespaces</a>.</p>
<p>Every <code>impl</code> file automatically imports the <code>api</code> file for its library.</p>
<p>All <code>import</code> declarations must appear before all other non-<code>package</code> declarations in the file.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="code_and_name_organization">Code and name organization</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/107">#107: Code and name organization</a></li>
</ul>
</blockquote>
<h3 id="name-visibility">Name visibility</h3>
<p>The names visible from an imported library are determined by these rules:</p>
<ul>
<li>Declarations in an <code>api</code> file are by default <em>public</em>, which means visible to any file that imports that library. This matches class members, which are also <a href="#access-control">default public</a>.</li>
<li>A <code>private</code> prefix on a declaration in an <code>api</code> file makes the name <em>library private</em>. This means the name is visible in the file and all <code>impl</code> files for the same library.</li>
<li>The visibility of a name is determined by its first declaration, considering <code>api</code> files before <code>impl</code> files. The <code>private</code> prefix is only allowed on the first declaration.</li>
<li>A name declared in an <code>impl</code> file and not the corresponding <code>api</code> file is <em>file private</em>, meaning visible in just that file. Its first declaration must be marked with a <code>private</code> prefix. <strong>TODO:</strong> This needs to be finalized in a proposal to resolve inconsistency between <a href="https://github.com/carbon-language/carbon-lang/issues/665#issuecomment-914661914">#665</a> and <a href="https://github.com/carbon-language/carbon-lang/issues/1136">#1136</a>.</li>
<li>Private names don't conflict with names outside the region they're private to: two different libraries can have different private names <code>foo</code> without conflict, but a private name conflicts with a public name in the same scope.</li>
</ul>
<p>At most one <code>api</code> file in a package transitively used in a program may declare a given name public.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="code_and_name_organization/index.html#exporting-entities-from-an-api-file">Exporting entities from an API file</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/665">#665: <code>private</code> vs <code>public</code> <em>syntax</em> strategy, as well as other visibility tools like <code>external</code>/<code>api</code>/etc.</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/752">#752: api file default public</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/931">#931: Generic impls access (details 4)</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/1136">#1136: what is the top-level scope in a source file, and what names are found there?</a></li>
</ul>
</blockquote>
<h3 id="package-scope">Package scope</h3>
<p>The top-level scope in a package is the scope of the package. This means:</p>
<ul>
<li>Within this scope (and its sub-namespaces), all visible names from the same package appear. This includes names from the same file, names from the <code>api</code> file of a library when inside an <code>impl</code> file, and names from imported libraries of the same package.</li>
<li>In scopes where package members might have a name conflict with something else, the syntax <code>package.Foo</code> can be used to name the <code>Foo</code> member of the current package.</li>
</ul>
<p>In this example, the names <code>F</code> and <code>P</code> are used in a scope where they could mean two different things, and <a href="#name-lookup">qualifications are needed to disambiguate</a>:</p>
<pre class="carbon"><code>import P;
fn F();
class C {
  fn F();
  class P {
    fn H();
  }
  fn G() {
    // ❌ Error: ambiguous whether `F` means
    // `package.F` or `package.C.F`.
    F();
   // ✅ Allowed: fully qualified
    package.F();
    package.C.F();
    // ✅ Allowed: unambiguous
    C.F();
    // ❌ Error: ambiguous whether `P` means
    // `package.P` or `package.P.F`.
    P.H();
    // ✅ Allowed
    package.P.H();
    package.C.P.H();
    C.P.H();
  }
}</code></pre>
<blockquote>
<p>References:</p>
<ul>
<li><a href="code_and_name_organization">Code and name organization</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/107">#107: Code and name organization</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/752">#752: api file default public</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/1136">#1136: what is the top-level scope in a source file, and what names are found there?</a></li>
</ul>
</blockquote>
<h3 id="namespaces">Namespaces</h3>
<p>A <code>namespace</code> declaration defines a name that may be used as a prefix of names declared afterward. When defining a member of a namespace, other members of that namespace are considered in scope and may be found by <a href="#name-lookup">name lookup</a> without the namespace prefix. In this example, package <code>P</code> defines some of its members inside a namespace <code>N</code>:</p>
<pre class="carbon"><code>package P api;

// Defines namespace `N` within the current package.
namespace N;

// Defines namespaces `M` and `M.L`.
namespace M.L;

fn F();
// ✅ Allowed: Declares function `G` in namespace `N`.
private fn N.G();
// ❌ Error: `Bad` hasn&#39;t been declared.
fn Bad.H();

fn J() {
  // ❌ Error: No `package.G`
  G();
}

fn N.K() {
  // ✅ Allowed: Looks in both `package` and `package.N`.
  // Finds `package.F` and `package.N.G`.
  F();
  G();
}

// ✅ Allowed: Declares function `R` in namespace `M.L`.
fn M.L.R();
// ✅ Allowed: Declares function `Q` in namespace `M`.
fn M.Q();</code></pre>
<p>Another package importing <code>P</code> can refer to the public members of that namespace by prefixing with the package name <code>P</code> followed by the namespace:</p>
<pre class="carbon"><code>import P;

// ✅ Allowed: `F` is public member of `P`.
P.F();
// ❌ Error: `N.G` is a private member of `P`.
P.N.G();
// ✅ Allowed: `N.K` is public member of `P`.
P.N.K();
// ✅ Allowed: `M.L.R` is public member of `P`.
P.M.L.R();
// ✅ Allowed: `M.Q` is public member of `P`.
P.M.Q();</code></pre>
<blockquote>
<p>References:</p>
<ul>
<li><a href="code_and_name_organization/index.html#namespaces">"Namespaces" in "Code and name organization"</a></li>
<li><a href="expressions/member_access.html#package-and-namespace-members">"Package and namespace members" in "Qualified names and member access"</a></li>
</ul>
</blockquote>
<h3 id="naming-conventions">Naming conventions</h3>
<p>Our naming conventions are:</p>
<ul>
<li>For idiomatic Carbon code:
<ul>
<li><code>UpperCamelCase</code> will be used when the named entity cannot have a dynamically varying value. For example, functions, namespaces, or compile-time constant values. Note that <a href="#inheritance"><code>virtual</code> methods</a> are named the same way to be consistent with other functions and methods.</li>
<li><code>lower_snake_case</code> will be used when the named entity's value won't be known until runtime, such as for variables.</li>
</ul></li>
<li>For Carbon-provided features:
<ul>
<li>Keywords and type literals will use <code>lower_snake_case</code>.</li>
<li>Other code will use the conventions for idiomatic Carbon code.</li>
</ul></li>
</ul>
<blockquote>
<p>References:</p>
<ul>
<li><a href="naming_conventions.html">Naming conventions</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/861">#861: Naming conventions</a></li>
</ul>
</blockquote>
<h3 id="aliases">Aliases</h3>
<p><code>alias</code> declares a name as equivalent to another name, for example:</p>
<pre class="carbon"><code>alias NewName = SomePackage.OldName;</code></pre>
<p>Note that the right-hand side of the equal sign (<code>=</code>) is a name not a value, so <code>alias four = 4;</code> is not allowed. This allows <code>alias</code> to work with entities like namespaces, which aren't values in Carbon.</p>
<p>This can be used during an incremental migration when changing a name, or to include a name in a public API. For example, <code>alias</code> may be used to include a name from an interface implementation as a member of a class or <a href="generics/details.html#named-constraints">named constraint</a>, possibly renamed:</p>
<pre class="carbon"><code>class ContactInfo {
  external impl as Printable;
  external impl as ToPrinterDevice;
  alias PrintToScreen = Printable.Print;
  alias PrintToPrinter = ToPrinterDevice.Print;
  ...
}</code></pre>
<blockquote>
<p>References:</p>
<ul>
<li><a href="aliases.html">Aliases</a></li>
<li><a href="code_and_name_organization/index.html#aliasing">"Aliasing" in "Code and name organization"</a></li>
<li><a href="generics/details.html#external-impl"><code>alias</code> a name from an external impl</a></li>
<li><a href="generics/details.html#named-constraints"><code>alias</code> a name in a named constraint</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/553">#553: Generics details part 1</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/749">#749: Alias syntax</a></li>
</ul>
</blockquote>
<h3 id="name-lookup">Name lookup</h3>
<p>The general principle of Carbon name lookup is that we look up names in all relevant scopes, and report an error if the name is found to refer to more than one different entity. So Carbon requires disambiguation by adding qualifiers instead of doing any <a href="https://en.wikipedia.org/wiki/Variable_shadowing">shadowing</a> of names. For an example, see <a href="#package-scope">the "package scope" section</a>.</p>
<p>Unqualified name lookup walks the semantically-enclosing scopes, not only the lexically-enclosing ones. So when a lookup is performed within <code>fn MyNamespace.MyClass.MyNestedClass.MyFunction()</code>, we will look in <code>MyNestedClass</code>, <code>MyClass</code>, <code>MyNamespace</code>, and the package scope, even when the lexically-enclosing scope is the package scope. This means that the definition of a method will look for names in the class' scope even if it is written lexically out of line:</p>
<pre><code>class C {
  fn F();
  fn G();
}
fn C.G() {
  // ✅ Allowed: resolves to `package.C.F`.
  F();
}</code></pre>
<p><a href="expressions/member_access.html">Member name lookup</a> follows a similar philosophy. If a <a href="#checked-and-template-parameters">checked-generic type parameter</a> is known to implement multiple interfaces due to a constraint using <a href="#combining-constraints"><code>&amp;</code></a> or <a href="generics/details.html#where-constraints"><code>where</code> clauses</a>, member name lookup into that type will look in all of the interfaces. If it is found in multiple, the name must be disambiguated by qualifying using compound member access (<a href="expressions/member_access.html">1</a>, <a href="generics/details.html#qualified-member-names-and-compound-member-access">2</a>). A <a href="#checked-and-template-parameters">template-generic type parameter</a> performs look up into the caller's type in addition to the constraint.</p>
<p>Carbon also rejects cases that would be invalid if all declarations in the file, including ones appearing later, were visible everywhere, not only after their point of appearance:</p>
<pre class="carbon"><code>class C {
  fn F();
  fn G();
}
fn C.G() {
  F();
}
// Error: use of `F` in `C.G` would be ambiguous
// if this declaration was earlier.
fn F();</code></pre>
<blockquote>
<p>References:</p>
<ul>
<li><a href="name_lookup.html">Name lookup</a></li>
<li><a href="expressions/index.html#qualified-names-and-member-access">"Qualified names and member access" section of "Expressions"</a></li>
<li><a href="expressions/member_access.html">Qualified names and member access</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/project/principles/information_accumulation.md">Principle: Information accumulation</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/875">#875: Principle: information accumulation</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/989">#989: Member access expressions</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/1136">#1136: what is the top-level scope in a source file, and what names are found there?</a></li>
</ul>
</blockquote>
<h4 id="name-lookup-for-common-types">Name lookup for common types</h4>
<p>Common types that we expect to be used universally will be provided for every file are made available as if there was a special "prelude" package that was imported automatically into every <code>api</code> file. Dedicated type literal syntaxes like <code>i32</code> and <code>bool</code> refer to types defined within this package, based on the <a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/project/principles/library_apis_only.md">"all APIs are library APIs" principle</a>.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="name_lookup.html">Name lookup</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/project/principles/library_apis_only.md">Principle: All APIs are library APIs</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/750">#750: Naming conventions for Carbon-provided features</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/1058">#1058: How should interfaces for core functionality be named?</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/1280">#1280: Principle: All APIs are library APIs</a></li>
</ul>
</blockquote>
<h2 id="generics">Generics</h2>
<p>Generics allow Carbon constructs like <a href="#functions">functions</a> and <a href="#classes">classes</a> to be written with compile-time parameters and apply generically to different types using those parameters. For example, this <code>Min</code> function has a type parameter <code>T</code> that can be any type that implements the <code>Ordered</code> interface.</p>
<pre class="carbon"><code>fn Min[T:! Ordered](x: T, y: T) -&gt; T {
  // Can compare `x` and `y` since they have
  // type `T` known to implement `Ordered`.
  return if x &lt;= y then x else y;
}

var a: i32 = 1;
var b: i32 = 2;
// `T` is deduced to be `i32`
Assert(Min(a, b) == 1);
// `T` is deduced to be `String`
Assert(Min(&quot;abc&quot;, &quot;xyz&quot;) == &quot;abc&quot;);</code></pre>
<p>Since the <code>T</code> type parameter is in the deduced parameter list in square brackets (<code>[</code>...<code>]</code>) before the explicit parameter list in parentheses (<code>(</code>...<code>)</code>), the value of <code>T</code> is determined from the types of the explicit arguments instead of being passed as a separate explicit argument.</p>
<blockquote>
<p>References: <strong>TODO:</strong> Revisit</p>
<ul>
<li><a href="generics/overview.html">Generics: Overview</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/524">#524: Generics overview</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/553">#553: Generics details part 1</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/950">#950: Generic details 6: remove facets</a></li>
</ul>
</blockquote>
<h3 id="checked-and-template-parameters">Checked and template parameters</h3>
<p>The <code>:!</code> indicates that <code>T</code> is a <em>checked</em> parameter passed at compile time. "Checked" here means that the body of <code>Min</code> is type checked when the function is defined, independent of the specific type values <code>T</code> is instantiated with, and name lookup is delegated to the constraint on <code>T</code> (<code>Ordered</code> in this case). This type checking is equivalent to saying the function would pass type checking given any type <code>T</code> that implements the <code>Ordered</code> interface. Then calls to <code>Min</code> only need to check that the deduced type value of <code>T</code> implements <code>Ordered</code>.</p>
<p>The parameter could alternatively be declared to be a <em>template</em> parameter by prefixing with the <code>template</code> keyword, as in <code>template T:! Type</code>.</p>
<pre class="carbon"><code>fn Convert[template T:! Type](source: T, template U:! Type) -&gt; U {
  var converted: U = source;
  return converted;
}

fn Foo(i: i32) -&gt; f32 {
  // Instantiates with the `T` implicit argument set to `i32` and the `U`
  // explicit argument set to `f32`, then calls with the runtime value `i`.
  return Convert(i, f32);
}</code></pre>
<p>Carbon templates follow the same fundamental paradigm as <a href="https://en.wikipedia.org/wiki/Template_(C%2B%2B)">C++ templates</a>: they are instantiated when called, resulting in late type checking, duck typing, and lazy binding.</p>
<p>One difference from C++ templates, Carbon template instantiation is not controlled by the SFINAE rule of C++ (<a href="https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">1</a>, <a href="https://en.cppreference.com/w/cpp/language/sfinae">2</a>) but by explicit <code>if</code> clauses evaluated at compile-time. The <code>if</code> clause is at the end of the declaration, and the condition can only use constant values known at type-checking time, including <code>template</code> parameters.</p>
<pre class="carbon"><code>class Array(template T:! Type, template N:! i64)
    if N &gt;= 0 and N &lt; MaxArraySize / sizeof(T);</code></pre>
<p>Member lookup into a template type parameter is done in the actual type value provided by the caller, <em>in addition</em> to any constraints. This means member name lookup and type checking for anything <a href="generics/terminology.html#dependent-names">dependent</a> on the template parameter can't be completed until the template is instantiated with a specific concrete type. When the constraint is just <code>Type</code>, this gives semantics similar to C++ templates. Constraints can then be added incrementally, with the compiler verifying that the semantics stay the same. Once all constraints have been added, removing the word <code>template</code> to switch to a checked parameter is safe.</p>
<p>The <a href="#value-categories-and-value-phases">value phase</a> of a checked parameter is a symbolic value whereas the value phase of a template parameter is constant.</p>
<p>Although checked generics are generally preferred, templates enable translation of code between C++ and Carbon, and address some cases where the type checking rigor of generics are problematic.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="templates.html">Templates</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/553">#553: Generics details part 1</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/949">#949: Constrained template name lookup</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/989">#989: Member access expressions</a></li>
</ul>
</blockquote>
<h3 id="interfaces-and-implementations">Interfaces and implementations</h3>
<p><em>Interfaces</em> specify a set of requirements that a types might satisfy. Interfaces act both as constraints on types a caller might supply and capabilities that may be assumed of types that satisfy that constraint.</p>
<pre class="carbon"><code>interface Printable {
  // Inside an interface definition `Self` means
  // &quot;the type implementing this interface&quot;.
  fn Print[me: Self]();
}</code></pre>
<p>In addition to function requirements, interfaces can contain:</p>
<ul>
<li><a href="generics/details.html#interface-requiring-other-interfaces">requirements that other interfaces be implemented</a> or <a href="generics/details.html#interface-extension">interfaces that this interface extends</a></li>
<li><a href="generics/details.html#associated-types">associated types</a> and other <a href="generics/details.html#associated-constants">associated constants</a></li>
<li><a href="generics/details.html#interface-defaults">interface defaults</a></li>
<li><a href="generics/details.html#final-members"><code>final</code> interface members</a></li>
</ul>
<p>Types only implement an interface if there is an explicit <code>impl</code> declaration that they do. Simply having a <code>Print</code> function with the right signature is not sufficient.</p>
<pre class="carbon"><code>class Circle {
  var radius: f32;

  impl as Printable {
    fn Print[me: Self]() {
      Console.WriteLine(&quot;Circle with radius: {0}&quot;, me.radius);
    }
  }
}</code></pre>
<p>In this case, <code>Print</code> is a member of <code>Circle</code>. Interfaces may also be implemented <a href="generics/details.html#external-impl">externally</a>, which means the members of the interface are not direct members of the type. Those methods may still be called using compound member access syntax (<a href="expressions/member_access.html">1</a>, <a href="generics/details.html#qualified-member-names-and-compound-member-access">2</a>) to qualify the name of the member, as in <code>x.(Printable.Print)()</code>. External implementations don't have to be in the same library as the type definition, subject to the orphan rule (<a href="generics/details.html#impl-lookup">1</a>, <a href="generics/details.html#orphan-rule">2</a>) for <a href="generics/terminology.html#coherence">coherence</a>.</p>
<p>Interfaces and implementations may be <a href="generics/details.html#forward-declarations-and-cyclic-references">forward declared</a> by replacing the definition scope in curly braces (<code>{</code>...<code>}</code>) with a semicolon.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="generics/details.html#interfaces">Generics: Interfaces</a></li>
<li><a href="generics/details.html#implementing-interfaces">Generics: Implementing interfaces</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/553">#553: Generics details part 1</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/731">#731: Generics details 2: adapters, associated types, parameterized interfaces</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/624">#624: Coherence: terminology, rationale, alternatives considered</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/990">#990: Generics details 8: interface default and final members</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/1084">#1084: Generics details 9: forward declarations</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/1132">#1132: How do we match forward declarations with their definitions?</a></li>
</ul>
</blockquote>
<h3 id="combining-constraints">Combining constraints</h3>
<p>A function can require calling types to implement multiple interfaces by combining them using an ampersand (<code>&amp;</code>):</p>
<pre class="carbon"><code>fn PrintMin[T:! Ordered &amp; Printable](x: T, y: T) {
  // Can compare since type `T` implements `Ordered`.
  if (x &lt;= y) {
    // Can call `Print` since type `T` implements `Printable`.
    x.Print();
  } else {
    y.Print();
  }
}</code></pre>
<p>The body of the function may call functions that are in either interface, except for names that are members of both. In that case, use the compound member access syntax (<a href="expressions/member_access.html">1</a>, <a href="generics/details.html#qualified-member-names-and-compound-member-access">2</a>) to qualify the name of the member, as in:</p>
<pre class="carbon"><code>fn DrawTies[T:! Renderable &amp; GameResult](x: T) {
  if (x.(GameResult.Draw)()) {
    x.(Renderable.Draw)();
  }
}</code></pre>
<blockquote>
<p>References:</p>
<ul>
<li><a href="generics/details.html#combining-interfaces-by-anding-type-of-types">Combining interfaces by anding type-of-types</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/531">#531: Combine interfaces with <code>+</code> or <code>&amp;</code></a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/553">#553: Generics details part 1</a></li>
</ul>
</blockquote>
<h3 id="associated-types">Associated types</h3>
<p>An associated type is a type member of an interface whose value is determined by the implementation of that interface for a specific type. These values are set to compile-time values in implementations, and so use the <a href="#checked-and-template-parameters"><code>:!</code> generic syntax</a> inside a <a href="#constant-let-declarations"><code>let</code> declaration</a> without an initializer. This allows types in the signatures of functions in the interface to vary. For example, an interface describing a <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">stack</a> might use an associated type to represent the type of elements stored in the stack.</p>
<pre><code>interface StackInterface {
  let ElementType:! Movable;
  fn Push[addr me: Self*](value: ElementType);
  fn Pop[addr me: Self*]() -&gt; ElementType;
  fn IsEmpty[addr me: Self*]() -&gt; bool;
}</code></pre>
<p>Then different types implementing <code>StackInterface</code> can specify different type values for the <code>ElementType</code> member of the interface using a <code>where</code> clause:</p>
<pre class="carbon"><code>class IntStack {
  impl as StackInterface where .ElementType == i32 {
    fn Push[addr me: Self*](value: i32);
    // ...
  }
}

class FruitStack {
  impl as StackInterface where .ElementType == Fruit {
    fn Push[addr me: Self*](value: Fruit);
    // ...
  }
}</code></pre>
<blockquote>
<p>References:</p>
<ul>
<li><a href="generics/details.html#associated-types">Generics: Associated types</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/731">#731: Generics details 2: adapters, associated types, parameterized interfaces</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/1013">#1013: Generics: Set associated constants using <code>where</code> constraints</a></li>
</ul>
</blockquote>
<h3 id="generic-entities">Generic entities</h3>
<p>Many Carbon entities, not just functions, may be made generic by adding <a href="#checked-and-template-parameters">checked or template parameters</a>.</p>
<h4 id="generic-classes">Generic Classes</h4>
<p>Classes may be defined with an optional explicit parameter list. All parameters to a class must be generic, and so defined with <code>:!</code>, either with or without the <code>template</code> prefix. For example, to define a stack that can hold values of any type <code>T</code>:</p>
<pre class="carbon"><code>class Stack(T:! Type) {
  fn Push[addr me: Self*](value: T);
  fn Pop[addr me: Self*]() -&gt; T;

  var storage: Array(T);
}

var int_stack: Stack(i32);</code></pre>
<p>In this example:</p>
<ul>
<li><code>Stack</code> is a type parameterized by a type <code>T</code>.</li>
<li><code>T</code> may be used within the definition of <code>Stack</code> anywhere a normal type would be used.</li>
<li><code>Array(T)</code> instantiates generic type <code>Array</code> with its parameter set to <code>T</code>.</li>
<li><code>Stack(i32)</code> instantiates <code>Stack</code> with <code>T</code> set to <code>i32</code>.</li>
</ul>
<p>The values of type parameters are part of a type's value, and so may be deduced in a function call, as in this example:</p>
<pre class="carbon"><code>fn PeekTopOfStack[T:! Type](s: Stack(T)*) -&gt; T {
  var top: T = s-&gt;Pop();
  s-&gt;Push(top);
  return top;
}

// `int_stack` has type `Stack(i32)`, so `T` is deduced to be `i32`.
PeekTopOfStack(&amp;int_stack);</code></pre>
<blockquote>
<p>References:</p>
<ul>
<li><a href="generics/details.html#parameterized-types">Generic or parameterized types</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/1146">#1146: Generic details 12: parameterized types</a></li>
</ul>
</blockquote>
<h4 id="generic-choice-types">Generic choice types</h4>
<p><a href="#choice-types">Choice types</a> may be parameterized similarly to classes:</p>
<pre class="carbon"><code>choice Result(T:! Type, Error:! Type) {
  Success(value: T),
  Failure(error: Error)
}</code></pre>
<h4 id="generic-interfaces">Generic interfaces</h4>
<p>Interfaces are always parameterized by a <code>Self</code> type, but in some cases they will have additional parameters.</p>
<pre class="carbon"><code>interface AddWith(U:! Type);</code></pre>
<p>Interfaces without parameters may only be implemented once for a given type, but a type can have distinct implementations of <code>AddWith(i32)</code> and <code>AddWith(BigInt)</code>.</p>
<p>Parameters to an interface <em>determine</em> which implementation is selected for a type, in contrast to <a href="#associated-types">associated types</a> which are <em>determined by</em> the implementation of an interface for a type.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="generics/details.html#parameterized-interfaces">Generic or parameterized interfaces</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/731">#731: Generics details 2: adapters, associated types, parameterized interfaces</a></li>
</ul>
</blockquote>
<h4 id="generic-implementations">Generic implementations</h4>
<p>An <code>impl</code> declaration may be parameterized by adding <code>forall [</code><em>generic parameter list</em><code>]</code> after the <code>impl</code> keyword introducer, as in:</p>
<pre class="carbon"><code>external impl forall [T:! Printable] Vector(T) as Printable;
external impl forall [Key:! Hashable, Value:! Type]
    HashMap(Key, Value) as Has(Key);
external impl forall [T:! Ordered] T as PartiallyOrdered;
external impl forall [T:! ImplicitAs(i32)] BigInt as AddWith(T);
external impl forall [U:! Type, T:! As(U)]
    Optional(T) as As(Optional(U));</code></pre>
<p>Generic implementations can create a situation where multiple <code>impl</code> definitions apply to a given type and interface query. The <a href="generics/details.html#lookup-resolution-and-specialization">specialization</a> rules pick which definition is selected. These rules ensure:</p>
<ul>
<li>Implementations have <a href="generics/terminology.html#coherence">coherence</a>, so the same implementation is always selected for a given query.</li>
<li>Libraries will work together as long as they pass their separate checks.</li>
<li>A generic function can assume that some impl will be successfully selected if it can see an impl that applies, even though another more specific impl may be selected.</li>
</ul>
<p>Implementations may be marked <a href="generics/details.html#final-impls"><code>final</code></a> to indicate that they may not be specialized, subject to <a href="generics/details.html#libraries-that-can-contain-final-impls">some restrictions</a>.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="generics/details.html#parameterized-impls">Generic or parameterized impls</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/624">#624: Coherence: terminology, rationale, alternatives considered</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/920">#920: Generic parameterized impls (details 5)</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/983">#983: Generics details 7: final impls</a></li>
</ul>
</blockquote>
<h3 id="other-features">Other features</h3>
<p>Carbon generics have a number of other features, including:</p>
<ul>
<li><a href="generics/details.html#named-constraints">Named constraints</a> may be used to disambiguate when combining two interfaces that have name conflicts. Named constraints may be implemented and otherwise used in place of an interface.</li>
<li><a href="generics/details.html#named-constraints">Template constraints</a> are a kind of named constraint that can contain structural requirements. For example, a template constraint could match any type that has a function with a specific name and signature without any explicit declaration that the type implements the constraint. Template constraints may only be used as requirements for template parameters.</li>
<li>An <a href="generics/details.html#adapting-types">adapter type</a> is a type with the same data representation as an existing type, so you may cast between the two types, but can implement different interfaces or implement interfaces differently.</li>
<li>Additional requirements can be placed on the associated types of an interface using <a href="generics/details.html#where-constraints"><code>where</code> constraints</a>.</li>
<li><a href="generics/details.html#implied-constraints">Implied constraints</a> allows some constraints to be deduced and omitted from a function signature.</li>
<li><a href="generics/details.html#runtime-type-fields">Dynamic erased types</a> can hold any value with a type implementing an interface, and allows the functions in that interface to be called using <a href="https://en.wikipedia.org/wiki/Dynamic_dispatch">dynamic dispatch</a>, for some interfaces marked "<code>dyn</code>-safe".</li>
<li><a href="generics/details.html#variadic-arguments">Variadics</a> supports variable-length parameter lists.</li>
</ul>
<blockquote>
<p>References:</p>
<ul>
<li><a href="generics/details.html">Generics details</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/553">#553: Generics details part 1</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/731">#731: Generics details 2: adapters, associated types, parameterized interfaces</a></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/818">#818: Constraints for generics (generics details 3)</a></li>
</ul>
</blockquote>
<h3 id="generic-type-equality-and-observe-declarations">Generic type equality and <code>observe</code> declarations</h3>
<p>Determining whether two types must be equal in a generic context is in general undecidable, as <a href="https://forums.swift.org/t/swift-type-checking-is-undecidable/39024">has been shown in Swift</a>.</p>
<p>To make compilation fast, the Carbon compiler will limit its search to a depth of 1, only identifying types as equal if there is an explicit declaration that they are equal in the code, such as in a <a href="generics/details.html#where-constraints"><code>where</code> constraint</a>. There will be situations where two types must be equal as the result of combining these facts, but the compiler will return a type error since it did not realize they are equal due to the limit of the search. An <a href="generics/details.html#observe-declarations"><code>observe</code>...<code>==</code> declaration</a> may be added to describe how two types are equal, allowing more code to pass type checking.</p>
<p>An <code>observe</code> declaration showing types are equal can increase the set of interfaces the compiler knows that a type implements. It is also possible that knowing a type implements one interface implies that it implements another, from an <a href="generics/details.html#interface-requiring-other-interfaces">interface requirement</a> or <a href="#generic-implementations">generic implementation</a>. An <code>observe</code>...<code>is</code> declaration may be used to <a href="generics/details.html#observing-a-type-implements-an-interface">observe that a type implements an interface</a>.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="generics/details.html#observe-declarations">Generics: <code>observe</code> declarations</a></li>
<li><a href="generics/details.html#observing-a-type-implements-an-interface">Generics: Observing a type implements an interface</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/818">#818: Constraints for generics (generics details 3)</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/1088">#1088: Generic details 10: interface-implemented requirements</a></li>
</ul>
</blockquote>
<h3 id="operator-overloading">Operator overloading</h3>
<p>Uses of an operator in an <a href="#expressions">expression</a> is translated into a call to a method of an interface. For example, if <code>x</code> has type <code>T</code> and <code>y</code> has type <code>U</code>, then <code>x + y</code> is translated into a call to <code>x.(AddWith(U).Op)(y)</code>. So overloading of the <code>+</code> operator is accomplished by implementing interface <code>AddWith(U)</code> for type <code>T</code>. In order to support <a href="expressions/implicit_conversions.html">implicit conversion</a> of the first operand to type <code>T</code> and the second argument to type <code>U</code>, add the <code>like</code> keyword to both types in the <code>impl</code> declaration, as in:</p>
<pre class="carbon"><code>external impl like T as AddWith(like U) where .Result == V {
  // `Self` is `T` here
  fn Op[me: Self](other: U) -&gt; V { ... }
}</code></pre>
<p>When the operand types and result type are all the same, this is equivalent to implementing the <code>Add</code> interface:</p>
<pre class="carbon"><code>external impl T as Add {
  fn Op[me: Self](other: Self) -&gt; Self { ... }
}</code></pre>
<p>The interfaces that correspond to each operator are given by:</p>
<ul>
<li><a href="expressions/arithmetic.html#extensibility">Arithmetic</a>:
<ul>
<li><code>-x</code>: <code>Negate</code></li>
<li><code>x + y</code>: <code>Add</code> or <code>AddWith(U)</code></li>
<li><code>x - y</code>: <code>Sub</code> or <code>SubWith(U)</code></li>
<li><code>x * y</code>: <code>Mul</code> or <code>MulWith(U)</code></li>
<li><code>x / y</code>: <code>Div</code> or <code>DivWith(U)</code></li>
<li><code>x % y</code>: <code>Mod</code> or <code>ModWith(U)</code></li>
</ul></li>
<li><a href="expressions/bitwise.html#extensibility">Bitwise and shift operators</a>:
<ul>
<li><code>^x</code>: <code>BitComplement</code></li>
<li><code>x &amp; y</code>: <code>BitAnd</code> or <code>BitAndWith(U)</code></li>
<li><code>x | y</code>: <code>BitOr</code> or <code>BitOrWith(U)</code></li>
<li><code>x ^ y</code>: <code>BitXor</code> or <code>BitXorWith(U)</code></li>
<li><code>x &lt;&lt; y</code>: <code>LeftShift</code> or <code>LeftShiftWith(U)</code></li>
<li><code>x &gt;&gt; y</code>: <code>RightShift</code> or <code>RightShiftWith(U)</code></li>
</ul></li>
<li>Comparison:
<ul>
<li><code>x == y</code>, <code>x != y</code> overloaded by implementing <a href="expressions/comparison_operators.html#equality"><code>Eq</code> or <code>EqWith(U)</code></a></li>
<li><code>x &lt; y</code>, <code>x &gt; y</code>, <code>x &lt;= y</code>, <code>x &gt;= y</code> overloaded by implementing <a href="expressions/comparison_operators.html#ordering"><code>Ordered</code> or <code>OrderedWith(U)</code></a></li>
</ul></li>
<li>Conversion:
<ul>
<li><code>x as U</code> is rewritten to use the <a href="expressions/as_expressions.html#extensibility"><code>As(U)</code></a> interface</li>
<li>Implicit conversions use <a href="expressions/implicit_conversions.html#extensibility"><code>ImplicitAs(U)</code></a></li>
</ul></li>
<li><strong>TODO:</strong> <a href="#assignment-statements">Assignment</a>: <code>x = y</code>, <code>++x</code>, <code>x += y</code>, and so on</li>
<li><strong>TODO:</strong> Dereference: <code>*p</code></li>
<li><strong>TODO:</strong> <a href="#move">Move</a>: <code>~x</code></li>
<li><strong>TODO:</strong> Indexing: <code>a[3]</code></li>
<li><strong>TODO:</strong> Function call: <code>f(4)</code></li>
</ul>
<p>The <a href="expressions/logical_operators.html#overloading">logical operators can not be overloaded</a>.</p>
<p>Operators that result in <a href="#value-categories-and-value-phases">l-values</a>, such as dereferencing <code>*p</code> and indexing <code>a[3]</code>, have interfaces that return the address of the value. Carbon automatically dereferences the pointer to get the l-value.</p>
<p>Operators that can take multiple arguments, such as function calling operator <code>f(4)</code>, have a <a href="generics/details.html#variadic-arguments">variadic</a> parameter list.</p>
<p>Whether and how a value supports other operations, such as being copied, swapped, or set into an <a href="#unformed-state">unformed state</a>, is also determined by implementing corresponding interfaces for the value's type.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="generics/details.html#operator-overloading">Operator overloading</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/702">#702: Comparison operators</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/820">#820: Implicit conversions</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/845">#845: as expressions</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/1058">#1058: How should interfaces for core functionality be named?</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/1083">#1083: Arithmetic expressions</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/1191">#1191: Bitwise operators</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/1178">#1178: Rework operator interfaces</a></li>
</ul>
</blockquote>
<h4 id="common-type">Common type</h4>
<p>There are some situations where the common type for two types is needed:</p>
<ul>
<li><p>A <a href="expressions/if.html">conditional expression like <code>if c then t else f</code></a> returns a value with the common type of <code>t</code> and <code>f</code>.</p></li>
<li><p>If there are multiple parameters to a function with a type parameter, it will be set to the common type of the corresponding arguments, as in:</p>
<pre class="carbon"><code>fn F[T:! Type](x: T, y: T);

// Calls `F` with `T` set to the
// common type of `G()` and `H()`:
F(G(), H());</code></pre></li>
<li><p>The inferred return type of a function with <a href="#auto-return-type"><code>auto</code> return type</a> is the common type of its <code>return</code> statements.</p></li>
</ul>
<p>The common type is specified by implementing the <code>CommonTypeWith</code> interface:</p>
<pre class="carbon"><code>// Common type of `A` and `B` is `C`.
impl A as CommonTypeWith(B) where .Result == C { }</code></pre>
<p>The common type is required to be a type that both types have an <a href="expressions/implicit_conversions.html">implicit conversion</a> to.</p>
<blockquote>
<p>References:</p>
<ul>
<li><a href="expressions/if.html#finding-a-common-type"><code>if</code> expressions</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/911">#911: Conditional expressions</a></li>
<li>Question-for-leads issue <a href="https://github.com/carbon-language/carbon-lang/issues/1077">#1077: find a way to permit impls of CommonTypeWith where the LHS and RHS type overlap</a></li>
</ul>
</blockquote>
<h2 id="bidirectional-interoperability-with-c-and-c">Bidirectional interoperability with C and C++</h2>
<p>Interoperability, or <em>interop</em>, is the ability to call C and C++ code from Carbon code and the other way around. This ability achieves two goals:</p>
<ul>
<li>Allows sharing a code and library ecosystem with C and C++.</li>
<li>Allows incremental migration to Carbon from C and C++.</li>
</ul>
<p>Carbon's approach to interopp is most similar to <a href="interoperability/philosophy_and_goals.html#other-interoperability-layers">Java/Kotlin interop</a>, where the two languages are different, but share enough of runtime model that data from one side can be used from the other. For example, C++ and Carbon will use the same <a href="https://en.cppreference.com/w/cpp/language/memory_model">memory model</a>.</p>
<p>The design for interoperability between Carbon and C++ hinges on:</p>
<ol type="1">
<li>The ability to interoperate with a wide variety of code, such as classes/structs and <a href="https://en.wikipedia.org/wiki/Template_(C%2B%2B)">templates</a>, not just free functions.</li>
<li>A willingness to expose the idioms of C++ into Carbon code, and the other way around, when necessary to maximize performance of the interoperability layer.</li>
<li>The use of wrappers and generic programming, including templates, to minimize or eliminate runtime overhead.</li>
</ol>
<p>This feature will have some restrictions; only a subset of Carbon APIs will be available to C++ and a subset of C++ APIs will be available to Carbon.</p>
<ul>
<li>To achieve simplification in Carbon, its programming model will exclude some rarely used and complex features of C++. For example, there will be limitations on <a href="https://en.wikipedia.org/wiki/Multiple_inheritance">multiple inheritance</a>.</li>
<li>C or C++ features that compromise the performance of code that don't use that feature, like <a href="https://en.wikipedia.org/wiki/Run-time_type_information">RTTI</a> and <a href="https://en.wikipedia.org/wiki/Exception_handling">exceptions</a>, are in particular subject to revision in Carbon.</li>
</ul>
<blockquote>
<p>References:</p>
<ul>
<li><a href="interoperability/index.html">Bidirectional interoperability with C/C++</a></li>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/175">#175: C++ interoperability goals</a></li>
</ul>
</blockquote>
<h3 id="goals">Goals</h3>
<p>The <a href="interoperability/philosophy_and_goals.html#goals">goals for interop</a> include:</p>
<ul>
<li><a href="interoperability/philosophy_and_goals.html#support-mixing-carbon-and-c-toolchains">Support mixing Carbon and C++ toolchains</a></li>
<li><a href="interoperability/philosophy_and_goals.html#compatibility-with-the-c-memory-model">Compatibility with the C++ memory model</a></li>
<li><a href="interoperability/philosophy_and_goals.html#minimize-bridge-code">Minimize bridge code</a></li>
<li><a href="interoperability/philosophy_and_goals.html#unsurprising-mappings-between-c-and-carbon-types">Unsurprising mappings between C++ and Carbon types</a></li>
<li><a href="interoperability/philosophy_and_goals.html#allow-c-bridge-code-in-carbon-files">Allow C++ bridge code in Carbon files</a></li>
<li><a href="interoperability/philosophy_and_goals.html#carbon-inheritance-from-c-types">Carbon inheritance from C++ types</a></li>
<li><a href="interoperability/philosophy_and_goals.html#support-use-of-advanced-c-features">Support use of advanced C++ features</a></li>
<li><a href="interoperability/philosophy_and_goals.html#support-basic-c-interoperability">Support basic C interoperability</a></li>
</ul>
<blockquote>
<p>References:</p>
<ul>
<li><a href="interoperability/philosophy_and_goals.html#goals">Interoperability: Goals</a></li>
</ul>
</blockquote>
<h3 id="non-goals">Non-goals</h3>
<p>The <a href="interoperability/philosophy_and_goals.html#non-goals">non-goals for interop</a> include:</p>
<ul>
<li><a href="interoperability/philosophy_and_goals.html#full-parity-between-a-carbon-only-toolchain-and-mixing-ccarbon-toolchains">Full parity between a Carbon-only toolchain and mixing C++/Carbon toolchains</a></li>
<li><a href="interoperability/philosophy_and_goals.html#never-require-bridge-code">Never require bridge code</a></li>
<li><a href="interoperability/philosophy_and_goals.html#convert-all-c-types-to-carbon-types">Convert all C++ types to Carbon types</a></li>
<li><a href="interoperability/philosophy_and_goals.html#support-for-c-exceptions-without-bridge-code">Support for C++ exceptions without bridge code</a></li>
<li><a href="interoperability/philosophy_and_goals.html#cross-language-metaprogramming">Cross-language metaprogramming</a></li>
<li><a href="interoperability/philosophy_and_goals.html#offer-equivalent-support-for-languages-other-than-c">Offer equivalent support for languages other than C++</a></li>
</ul>
<blockquote>
<p>References:</p>
<ul>
<li><a href="interoperability/philosophy_and_goals.html#non-goals">Interoperability: Non-goals</a></li>
</ul>
</blockquote>
<h3 id="importing-and-include">Importing and <code>#include</code></h3>
<p>A C++ library header file may be <a href="#imports">imported</a> into Carbon using an <code>import</code> declaration of the special <code>Cpp</code> package.</p>
<pre class="carbon"><code>// like `#include &quot;circle.h&quot;` in C++
import Cpp library &quot;circle.h&quot;;</code></pre>
<p>This adds the names from <code>circle.h</code> into the <code>Cpp</code> namespace. If <code>circle.h</code> defines some names in a <code>namespace shapes { ... }</code> scope, those will be found in Carbon's <code>Cpp.shapes</code> namespace.</p>
<p>In the other direction, Carbon packages can export a header file to be <code>#include</code>d from C++ files.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="co">// like `import Geometry` in Carbon</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;geometry.carbon.h&quot;</span></span></code></pre></div>
<p>Generally Carbon entities will be usable from C++ and C++ entities will be usable from Carbon. This includes types, function, and constants. Some entities, such as Carbon interfaces, won't be able to be translated directly.</p>
<p>C and C++ macros that are defining constants will be imported as constants. Otherwise, C and C++ macros will be unavailable in Carbon. C and C++ <code>typedef</code>s would be translated into type constants, as if declared using a <a href="#constant-let-declarations"><code>let</code></a>.</p>
<p>Carbon functions and types that satisfy some restrictions may be annotated as exported to C as well, like C++'s <a href="https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B#Linking_C_and_C++_code"><code>extern "C"</code></a> marker.</p>
<h3 id="abi-and-dynamic-linking">ABI and dynamic linking</h3>
<p>Carbon itself will not have a stable ABI for the language as a whole, and most language features will be designed around not having any ABI stability. Instead, we expect to add dedicated language features that are specifically designed to provide an ABI-stable boundary between two separate parts of a Carbon program. These ABI-resilient language features and API boundaries will be opt-in and explicit. They may also have functionality restrictions to make them easy to implement with strong ABI resilience.</p>
<p>When interoperating with already compiled C++ object code or shared libraries, the C++ interop may be significantly less feature rich than otherwise. This is an open area for us to explore, but we expect to require re-compiling C++ code in order to get the full ergonomic and performance benefits when interoperating with Carbon. For example, recompilation lets us ensure Carbon and C++ can use the same representation for key vocabulary types.</p>
<p>However, we expect to have full support for the C ABI when interoperating with already-compiled C object code or shared libraries. We expect Carbon's bridge code functionality to cover similar use cases as C++'s <a href="https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B#Linking_C_and_C++_code"><code>extern "C"</code></a> marker in order to provide full bi-directional support here. The functionality available across this interop boundary will of course be restricted to what is expressible in the C ABI, and types may need explicit markers to have guaranteed ABI compatibility.</p>
<h3 id="operator-overloading-1">Operator overloading</h3>
<p><a href="#operator-overloading">Operator overloading</a> is supported in Carbon, but is done by <a href="#interfaces-and-implementations">implementing an interface</a> instead of defining a method or nonmember function as in C++.</p>
<p>Carbon types implementing an operator overload using an interface should get the corresponding operator overload in C++. So implementing <code>ModWith(U)</code> in Carbon for a type effectively implements <code>operator%</code> in C++ for that type. This also works in the other direction, so C++ types implementing an operator overload are automatically considered to implement the corresponding Carbon interface. So implementing <code>operator%</code> in C++ for a type also implements interface <code>ModWith(U)</code> in Carbon. However, there may be edge cases around implicit conversions or overload selection that don't map completely into Carbon.</p>
<p>In some cases, the operation might be written differently in the two languages. In those cases, they are matched according to which operation has the most similar semantics rather than using the same symbols. For example, the <code>^x</code> operation and <code>BitComplement</code> interface in Carbon corresponds to the <code>~x</code> operation and <code>operator~</code> function in C++. Similarly, the <code>ImplicitAs(U)</code> Carbon interface corresponds to implicit conversions in C++, which can be written in multiple different ways. Other <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html">C++ customization points</a> like <code>swap</code> will correspond to a Carbon interface, on a case-by-case basis.</p>
<p>Some operators will only exist or be overridable in C++, such as logical operators or the comma operator. In the unlikely situation where those operators need to be overridden for a Carbon type, that can be done with a nonmember C++ function.</p>
<p>Carbon interfaces with no C++ equivalent, such as <a href="#common-type"><code>CommonTypeWith(U)</code></a>, may be implemented for C++ types externally in Carbon code. To satisfy the orphan rule (<a href="generics/details.html#impl-lookup">1</a>, <a href="generics/details.html#orphan-rule">2</a>), each C++ library will have a corresponding Carbon wrapper library that must be imported instead of the C++ library if the Carbon wrapper exists. <strong>TODO:</strong> Perhaps it will automatically be imported, so a wrapper may be added without requiring changes to importers?</p>
<h3 id="templates">Templates</h3>
<p>Carbon supports both <a href="#checked-and-template-parameters">checked and template generics</a>. This provides a migration path for C++ template code:</p>
<ul>
<li>C++ template -&gt; Carbon template: This involves migrating the code from C++ to Carbon. If that migration is faithful, the change should be transparent to callers.</li>
<li>-&gt; Carbon template with constraints: Constraints may be added one at a time. Adding a constraint never changes the meaning of the code as long as it continues to compile. Compile errors will point to types for which an implementation of missing interfaces is needed. A temporary template implementation of that interface can act as a bridge during the transition.</li>
<li>-&gt; Carbon checked generic: Once all callers work after all constraints have been added, the template parameter may be switched to a checked generic.</li>
</ul>
<p>Carbon will also provide direct interop with C++ templates in many ways:</p>
<ul>
<li>Ability to call C++ templates and use C++ templated types from Carbon.</li>
<li>Ability to instantiate a C++ template with a Carbon type.</li>
<li>Ability to instantiate a Carbon generic with a C++ type.</li>
</ul>
<p>We expect the best interop in these areas to be based on a Carbon-provided C++ toolchain. However, even when using Carbon's generated C++ headers for interop, we will include the ability where possible to use a Carbon generic from C++ as if it were a C++ template.</p>
<h3 id="standard-types">Standard types</h3>
<p>The Carbon integer types, like <code>i32</code> and <code>u64</code>, are considered equal to the corresponding fixed-width integer types in C++, like <code>int32_t</code> and <code>uint64_t</code>, provided by <code>&lt;stdint.h&gt;</code> or <code>&lt;cstdint&gt;</code>. The basic C and C++ integer types like <code>int</code>, <code>char</code>, and <code>unsigned long</code> are available in Carbon inside the <code>Cpp</code> namespace given an <code>import Cpp;</code> declaration, with names like <code>Cpp.int</code>, <code>Cpp.char</code>, and <code>Cpp.unsigned_long</code>. C++ types are considered different if C++ considers them different, so C++ overloads are resolved the same way. Carbon <a href="expressions/implicit_conversions.html#data-types">conventions for implicit conversions between integer types</a> apply here, allowing them whenever the numerical value for all inputs may be preserved by the conversion.</p>
<p>Other C and C++ types are equal to Carbon types as follows:</p>
<table>
<thead>
<tr class="header">
<th>C or C++</th>
<th>Carbon</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>bool</code></td>
<td><code>bool</code></td>
</tr>
<tr class="even">
<td><code>float</code></td>
<td><code>f32</code></td>
</tr>
<tr class="odd">
<td><code>double</code></td>
<td><code>f64</code></td>
</tr>
<tr class="even">
<td><code>T*</code></td>
<td><code>Optional(T*)</code></td>
</tr>
<tr class="odd">
<td><code>T[4]</code></td>
<td><code>[T; 4]</code></td>
</tr>
</tbody>
</table>
<p>Further, C++ reference types like <code>T&amp;</code> will be translated to <code>T*</code> in Carbon, which is Carbon's non-null pointer type.</p>
<p>Carbon will work to have idiomatic vocabulary <em>view</em> types for common data structures, like <code>std::string_view</code> and <code>std::span</code>, map transparently between C++ and the Carbon equivalents. This will include data layout so that even pointers to these types translate seamlessly, contingent on a suitable C++ ABI for those types, potentially by re-compiling the C++ code with a customized ABI. We will also explore how to expand coverage to similar view types in other libraries.</p>
<p>However, Carbon's containers will be distinct from the C++ standard library containers in order to maximize our ability to improve performance and leverage language features like checked generics in their design and implementation.</p>
<p>Where possible, we will also try to provide implementations of Carbon's standard library container <em>interfaces</em> for the relevant C++ container types so that they can be directly used with generic Carbon code. This should allow generic code in Carbon to work seamlessly with both Carbon and C++ containers without performance loss or constraining the Carbon container implementations. In the other direction, Carbon containers will satisfy C++ container requirements, so templated C++ code can operate directly on Carbon containers as well.</p>
<h3 id="inheritance-1">Inheritance</h3>
<p><a href="#inheritance">Carbon has single inheritance</a> allowing C++ classes using inheritance to be migrated. The data representation will be consistent so that Carbon classes may inherit from C++ classes, and the other way around, even with virtual methods.</p>
<p>C++ <a href="https://en.wikipedia.org/wiki/Multiple_inheritance">multiple inheritance</a> and <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a> will be migrated using a combination of Carbon features. Carbon mixins support implementation reuse and Carbon interfaces allow a type to implement multiple APIs. However, there may be limits on the degree of interop available with multiple inheritance across the C++ &lt;-&gt; Carbon boundaries.</p>
<p>Carbon dyn-safe interfaces may be exported to C++ as an <a href="https://en.wikipedia.org/wiki/Class_(computer_programming)#Abstract_and_concrete">abstract base class</a>. The reverse operation is also possible using a proxy object implementing a C++ abstract base class and holding a pointer to a type implementing the corresponding interface.</p>
<h3 id="enums">Enums</h3>
<blockquote>
<p><strong>TODO</strong></p>
</blockquote>
<h2 id="unfinished-tales">Unfinished tales</h2>
<h3 id="safety">Safety</h3>
<p>Carbon's premise is that C++ users can't give up performance to get safety. Even if some isolated users can make that tradeoff, they share code with performance-sensitive users. Any path to safety must preserve performance of C++ today. This rules out garbage collection, and many other options. The only well understood mechanism of achieving safety without giving up performance is compile-time safety. The leading example of how to achieve this is Rust.</p>
<p>The difference between Rust's approach and Carbon's is that Rust starts with safety and Carbons starts with migration. Rust supports interop with C, and there is ongoing work to improve the C++-interop story and develop migration tools. However, there is a large gap in programming models between the two languages, generally requiring a revision to the architecture. So, thus far the common pattern in the Rust community is to "rewrite it in Rust" (<a href="https://deprogrammaticaipsum.com/the-great-rewriting-in-rust/">1</a>, <a href="https://unhandledexpression.com/rust/2017/07/10/why-you-should-actually-rewrite-it-in-rust.html">2</a>, <a href="https://transitiontech.ca/random/RIIR">3</a>). Carbon's approach is to focus on migration from C++, including seamless interop, and then incrementally improve safety.</p>
<p>The first impact on Carbon's design to support its safety strategy are the necessary building blocks for this level of compile-time safety. We look at existing languages like Rust and Swift to understand what fundamental capabilities they ended up needing. The two components that stand out are:</p>
<ul>
<li>Expanded type system that includes more semantic information.</li>
<li>More pervasive use of type system abstractions (typically generics).</li>
</ul>
<p>For migrating C++ code, we also need the ability to add features and migrate code to use those new features incrementally and over time. This requires designing the language with evolution baked in on day one. This impacts a wide range of features:</p>
<ul>
<li>At the lowest level, a simple and extensible syntax and grammar.</li>
<li>Tools and support for adding and removing APIs.</li>
<li>Scalable migration strategies, including tooling support.</li>
</ul>
<p>Rust shows the value of expanded semantic information in the type system such as precise lifetimes. This is hard to do in C++ since it has too many kinds of references and pointers, which increases the complexity in the type system multiplicatively. Carbon is attempting to compress C++'s type variations into just values and <a href="#pointer-types">pointers</a>.</p>
<p>Rust also shows the value of functions parameterized by lifetimes. Since lifetimes are only used to establish safety properties of the code, there is no reason to pay the cost of monomorphization for those parameters. So we need a <a href="#generics">generics system</a> that can reason about code before it is instantiated, unlike C++ templates.</p>
<p>In conclusion, there are two patterns in how Carbon diverges from C++:</p>
<ul>
<li>Simplify and removing things to create space for new safety features. This trivially requires breaking backwards compatibility.</li>
<li>Re-engineer foundations to model and enforce safety. This has complex and difficulty in C++ without first simplifying the language.</li>
</ul>
<p>This leads to Carbon's incremental path to safety:</p>
<ul>
<li>Keep your performance, your existing codebase, and your developers.</li>
<li>Adopt Carbon through a scalable, tool-assisted migration from C++.</li>
<li>Address initial, easy safety improvements starting day one.</li>
<li>Shift the Carbon code onto an incremental path towards memory safety over the next decade.</li>
</ul>
<blockquote>
<p>References: <a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/project/principles/safety_strategy.md">Safety strategy</a></p>
</blockquote>
<h3 id="lifetime-and-move-semantics">Lifetime and move semantics</h3>
<blockquote>
<p><strong>TODO:</strong></p>
</blockquote>
<h3 id="metaprogramming">Metaprogramming</h3>
<blockquote>
<p><strong>TODO:</strong> References need to be evolved. Needs a detailed design and a high level summary provided inline.</p>
</blockquote>
<p>Carbon provides metaprogramming facilities that look similar to regular Carbon code. These are structured, and do not offer arbitrary inclusion or preprocessing of source text such as C and C++ do.</p>
<blockquote>
<p>References: <a href="metaprogramming.html">Metaprogramming</a></p>
</blockquote>
<h3 id="pattern-matching-as-function-overload-resolution">Pattern matching as function overload resolution</h3>
<blockquote>
<p><strong>TODO:</strong> References need to be evolved. Needs a detailed design and a high level summary provided inline.</p>
</blockquote>
<blockquote>
<p>References: <a href="pattern_matching.html">Pattern matching</a></p>
</blockquote>
<h3 id="error-handling">Error handling</h3>
<p>For now, Carbon does not have language features dedicated to error handling, but we would consider adding some in the future. At this point, errors are represented using <a href="#choice-types">choice types</a> like <code>Result</code> and <code>Optional</code>.</p>
<p>This is similar to the story for Rust, which started using <code>Result</code>, then added <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator"><code>?</code> operator</a> for convenience, and is now considering (<a href="https://yaah.dev/try-blocks">1</a>, <a href="https://doc.rust-lang.org/beta/unstable-book/language-features/try-blocks.html">2</a>) adding more.</p>
<h3 id="execution-abstractions">Execution abstractions</h3>
<p>Carbon provides some higher-order abstractions of program execution, as well as the critical underpinnings of such abstractions.</p>
<h4 id="abstract-machine-and-execution-model">Abstract machine and execution model</h4>
<blockquote>
<p><strong>TODO:</strong></p>
</blockquote>
<h4 id="lambdas">Lambdas</h4>
<blockquote>
<p><strong>TODO:</strong></p>
</blockquote>
<h4 id="co-routines">Co-routines</h4>
<blockquote>
<p><strong>TODO:</strong></p>
</blockquote>
<h4 id="concurrency">Concurrency</h4>
<blockquote>
<p><strong>TODO:</strong></p>
</blockquote>
