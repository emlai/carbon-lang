<h1 id="if-expressions"><code>if</code> expressions</h1>
<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

<!-- toc -->

<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#semantics">Semantics</a></li>
<li><a href="#finding-a-common-type">Finding a common type</a>
<ul>
<li><a href="#symmetry">Symmetry</a></li>
<li><a href="#same-type">Same type</a></li>
<li><a href="#implicit-conversions">Implicit conversions</a></li>
</ul></li>
<li><a href="#alternatives-considered">Alternatives considered</a></li>
<li><a href="#references">References</a></li>
</ul>
<!-- tocstop -->

<h2 id="overview">Overview</h2>
<p>An <code>if</code> expression is an expression of the form:</p>
<blockquote>
<p><code>if</code> <em>condition</em> <code>then</code> <em>value1</em> <code>else</code> <em>value2</em></p>
</blockquote>
<p>The <em>condition</em> is converted to a <code>bool</code> value in the same way as the condition of an <code>if</code> statement.</p>
<blockquote>
<p><strong>Note:</strong> These conversions have not yet been decided.</p>
</blockquote>
<p>The <em>value1</em> and <em>value2</em> are implicitly converted to their <a href="#finding-a-common-type">common type</a>, which is the type of the <code>if</code> expression.</p>
<h2 id="syntax">Syntax</h2>
<p><code>if</code> expressions have very low precedence, and cannot appear as the operand of any operator, except as the right-hand operand in an assignment. They can appear in other context where an expression is permitted, such as within parentheses, as the operand of a <code>return</code> statement, as an initializer, or in a comma-separated list such as a function call.</p>
<p>The <em>value1</em> and <em>value2</em> expressions are arbitrary expressions, and can themselves be <code>if</code> expressions. <em>value2</em> extends as far to the right as possible. An <code>if</code> expression can be parenthesized if the intent is for <em>value2</em> to end earlier.</p>
<pre><code>// OK, same as `if cond then (1 + 1) else (2 + (4 * 6))`
var a: i32 = if cond then 1 + 1 else 2 + 4 * 6;

// OK
var b: i32 = (if cond then 1 + 1 else 2) + 4 * 6;</code></pre>
<p>An <code>if</code> keyword at the start of a statement is always interpreted as an <a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/design/control_flow/conditionals.md"><code>if</code> statement</a>, never as an <code>if</code> expression, even if it is followed eventually by a <code>then</code> keyword.</p>
<h2 id="semantics">Semantics</h2>
<p>The converted <em>condition</em> is evaluated. If it evaluates to <code>true</code>, then the converted <em>value1</em> is evaluated and its value is the result of the expression. Otherwise, the converted <em>value2</em> is evaluated and its value is the result of the expression.</p>
<h2 id="finding-a-common-type">Finding a common type</h2>
<p>The common type of two types <code>T</code> and <code>U</code> is <code>(T as CommonType(U)).Result</code>, where <code>CommonType</code> is the <code>Carbon.CommonType</code> constraint. <code>CommonType</code> is notionally defined as follows:</p>
<pre><code>constraint CommonType(U:! CommonTypeWith(Self)) {
  extend CommonTypeWith(U) where .Result == U.Result;
}</code></pre>
<p>The actual definition is a bit more complex than this, as described in <a href="#symmetry">symmetry</a>.</p>
<p>The interface <code>CommonTypeWith</code> is used to customize the behavior of <code>CommonType</code>:</p>
<pre><code>interface CommonTypeWith(U:! Type) {
  let Result:! Type
    where Self is ImplicitAs(.Self) and
          U is ImplicitAs(.Self);
}</code></pre>
<p>The implementation <code>A as CommonTypeWith(B)</code> specifies the type that <code>A</code> would like to result from unifying <code>A</code> and <code>B</code> as its <code>Result</code>.</p>
<p><em>Note:</em> It is required that both types implicitly convert to the common type. Some blanket <code>impl</code>s for <code>CommonTypeWith</code> are provided as part of the prelude. These are described in the following sections.</p>
<p><em>Note:</em> The same mechanism is expected to eventually be used to compute common types in other circumstances.</p>
<h3 id="symmetry">Symmetry</h3>
<p>The common type of <code>T</code> and <code>U</code> should always be the same as the common type of <code>U</code> and <code>T</code>. This is enforced in two steps:</p>
<ul>
<li>A <code>SymmetricCommonTypeWith</code> interface implicitly provides a <code>B as CommonTypeWith(A)</code> implementation whenever one doesn't exist but an <code>A as CommonTypeWith(B)</code> implementation exists.</li>
<li><code>CommonType</code> is defined in terms of <code>SymmetricCommonTypeWith</code>, and requires that both <code>A as SymmetricCommonTypeWith(B)</code> and <code>B as SymmetricCommonTypeWith(A)</code> produce the same type.</li>
</ul>
<p>The interface <code>SymmetricCommonTypeWith</code> is an implementation detail of the <code>CommonType</code> constraint. It is defined and implemented as follows:</p>
<pre><code>interface SymmetricCommonTypeWith(U:! Type) {
  let Result:! Type
    where Self is ImplicitAs(.Self) and
          U is ImplicitAs(.Self);
}
match_first {
  impl [T:! Type, U:! CommonTypeWith(T)] T as SymmetricCommonTypeWith(U) {
    let Result:! Type = U.Result;
  }
  impl [U:! Type, T:! CommonTypeWith(U)] T as SymmetricCommonTypeWith(U) {
    let Result:! Type = T.Result;
  }
}</code></pre>
<p>The <code>SymmetricCommonTypeWith</code> interface is not exported, so user-defined <code>impl</code>s can't be defined, and only the two blanket <code>impl</code>s above are used. The <code>CommonType</code> constraint is then defined as follows:</p>
<pre><code>constraint CommonType(U:! SymmetricCommonTypeWith(Self)) {
  extend SymmetricCommonTypeWith(U) where .Result == U.Result;
}</code></pre>
<p>When computing the common type of <code>T</code> and <code>U</code>, if only one of the types provides a <code>CommonTypeWith</code> implementation, that determines the common type. If both types provide a <code>CommonTypeWith</code> implementation and their <code>Result</code> types are the same, that determines the common type. Otherwise, if both types provide implementations but their <code>Result</code> types differ, there is no common type, and the <code>CommonType</code> constraint is not met. For example, given:</p>
<pre><code>// Implementation #1
impl [T:! Type] MyX as CommonTypeWith(T) {
  let Result:! Type = MyX;
}

// Implementation #2
impl [T:! Type] MyY as CommonTypeWith(T) {
  let Result:! Type = MyY;
}</code></pre>
<p><code>MyX as CommonTypeWith(MyY)</code> will select #1, and <code>MyY as CommonTypeWith(MyX)</code> will select #2, but the constraints on <code>MyX as CommonType(MyY)</code> will not be met because result types differ.</p>
<h3 id="same-type">Same type</h3>
<p>If <code>T</code> is the same type as <code>U</code>, the result is that type:</p>
<pre><code>final impl [T:! Type] T as CommonTypeWith(T) {
  let Result:! Type = T;
}</code></pre>
<p><em>Note:</em> This rule is intended to be considered more specialized than the other rules in this document.</p>
<p>Because this <code>impl</code> is declared <code>final</code>, <code>T.(CommonType(T)).Result</code> is always assumed to be <code>T</code>, even in contexts where <code>T</code> involves a generic parameter and so the result would normally be an unknown type whose type-of-type is <code>Type</code>.</p>
<pre><code>fn F[T:! Hashable](c: bool, x: T, y: T) -&gt; HashCode {
  // OK, type of `if` expression is `T`.
  return (if c then x else y).Hash();
}</code></pre>
<h3 id="implicit-conversions">Implicit conversions</h3>
<p>If <code>T</code> implicitly converts to <code>U</code>, the common type is <code>U</code>:</p>
<pre><code>impl [T:! Type, U:! ImplicitAs(T)] T as CommonTypeWith(U) {
  let Result:! Type = T;
}</code></pre>
<p><em>Note:</em> If an implicit conversion is possible in both directions, and no more specific implementation exists, the constraints on <code>T as CommonType(U)</code> will not be met because <code>(T as CommonTypeWith(U)).Result</code> and <code>(U as CommonTypeWith(T)).Result</code> will differ. In order to define a common type for such a case, <code>CommonTypeWith</code> implementations in both directions must be provided to override the blanket <code>impl</code>s in both directions:</p>
<pre><code>impl MyString as CommonTypeWith(YourString) {
  let Result:! Type = MyString;
}
impl YourString as CommonTypeWith(MyString) {
  let Result:! Type = MyString;
}
var my_string: MyString;
var your_string: YourString;
// The type of `also_my_string` is `MyString`.
var also_my_string: auto = if cond then my_string else your_string;</code></pre>
<h2 id="alternatives-considered">Alternatives considered</h2>
<ul>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0911.md#no-conditional-expression">Provide no conditional expression</a></li>
<li>Use <a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0911.md#use-c-syntax"><code>cond ? expr1 : expr2</code>, like in C and C++</a> syntax</li>
<li>Use <a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0911.md#no-then"><code>if (cond) expr1 else expr2</code></a> syntax</li>
<li>Use <a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0911.md#require-parentheses-around-the-condition"><code>if (cond) then expr1 else expr2</code></a> syntax</li>
<li>Allow <a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0911.md#never-require-enclosing-parentheses"><code>1 + if cond then expr1 else expr2</code></a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0911.md#implicit-conversions-in-both-directions">Only require one <code>impl</code> to specify the common type if implicit conversions in both directions are possible</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0911.md#support-lvalue-conditionals">Introduce special rules for lvalue conditionals</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/911">#911: Conditional expressions</a>.</li>
</ul>
