<h1 id="code-and-name-organization">Code and name organization</h1>
<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

<!-- toc -->

<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#goals-and-philosophy">Goals and philosophy</a></li>
<li><a href="#overview">Overview</a>
<ul>
<li><a href="#sizing-packages-and-libraries">Sizing packages and libraries</a></li>
<li><a href="#imports">Imports</a></li>
</ul></li>
<li><a href="#details">Details</a>
<ul>
<li><a href="#source-file-introduction">Source file introduction</a></li>
<li><a href="#name-paths">Name paths</a>
<ul>
<li><a href="#package-directives"><code>package</code> directives</a></li>
</ul></li>
<li><a href="#packages">Packages</a>
<ul>
<li><a href="#shorthand-notation-for-libraries-in-packages">Shorthand notation for libraries in packages</a></li>
<li><a href="#package-name-conflicts">Package name conflicts</a></li>
</ul></li>
<li><a href="#libraries">Libraries</a>
<ul>
<li><a href="#exporting-entities-from-an-api-file">Exporting entities from an API file</a></li>
<li><a href="#granularity-of-libraries">Granularity of libraries</a></li>
<li><a href="#exporting-namespaces">Exporting namespaces</a></li>
</ul></li>
<li><a href="#imports-1">Imports</a>
<ul>
<li><a href="#imports-from-the-current-package">Imports from the current package</a></li>
</ul></li>
<li><a href="#namespaces">Namespaces</a>
<ul>
<li><a href="#re-declaring-imported-namespaces">Re-declaring imported namespaces</a></li>
<li><a href="#aliasing">Aliasing</a></li>
</ul></li>
</ul></li>
<li><a href="#caveats">Caveats</a>
<ul>
<li><a href="#package-and-library-name-conflicts">Package and library name conflicts</a></li>
<li><a href="#potential-refactorings">Potential refactorings</a>
<ul>
<li><a href="#update-imports">Update imports</a></li>
<li><a href="#between-api-and-impl-files">Between <code>api</code> and <code>impl</code> files</a></li>
<li><a href="#other-refactorings">Other refactorings</a></li>
</ul></li>
<li><a href="#preference-for-few-child-namespaces">Preference for few child namespaces</a></li>
<li><a href="#redundant-markers">Redundant markers</a></li>
</ul></li>
<li><a href="#open-questions">Open questions</a>
<ul>
<li><a href="#different-file-extensions">Different file extensions</a></li>
<li><a href="#imports-from-other-languages">Imports from other languages</a></li>
<li><a href="#imports-from-urls">Imports from URLs</a></li>
<li><a href="#test-file-type">Test file type</a></li>
</ul></li>
<li><a href="#alternatives-considered">Alternatives considered</a></li>
<li><a href="#references">References</a></li>
</ul>
<!-- tocstop -->

<h2 id="goals-and-philosophy">Goals and philosophy</h2>
<p>Important Carbon goals for code and name organization are:</p>
<ul>
<li><p><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/project/goals.md#language-tools-and-ecosystem">Language tools and ecosystem</a></p>
<ul>
<li><p>Tooling support is important for Carbon, including the possibility of a package manager.</p></li>
<li><p>Developer tooling, including both IDEs and refactoring tools, are expected to exist and be well-supported.</p></li>
</ul></li>
<li><p><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/project/goals.md#software-and-language-evolution">Software and language evolution</a>:</p>
<ul>
<li><p>We should support libraries adding new structs, functions or other identifiers without those new identifiers being able to shadow or break existing users that already have identifiers with conflicting names.</p></li>
<li><p>We should make it easy to refactor code, including moving code between files. This includes refactoring both by humans and by developer tooling.</p></li>
</ul></li>
<li><p><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/project/goals.md#fast-and-scalable-development">Fast and scalable development</a>:</p>
<ul>
<li><p>It should be easy for developer tooling to parse code, without needing to parse imports for context.</p></li>
<li><p>Structure should be provided for large projects to opt into features which will help maintain scaling of their codebase, while not adding burdens to small projects that don't need it.</p></li>
</ul></li>
</ul>
<h2 id="overview">Overview</h2>
<p>Carbon <a href="source_files.html">source files</a> have a <code>.carbon</code> extension, such as <code>geometry.carbon</code>. These files are the basic unit of compilation.</p>
<p>Each file begins with a declaration of which <em>package</em><sup><small>[<a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/guides/glossary.md#package">define</a>]</small></sup> it belongs in. The package is the unit of <em>distribution</em>. The package name is a single identifier, such as <code>Geometry</code>. An example API file in the <code>Geometry</code> package would start with:</p>
<pre><code>package Geometry api;</code></pre>
<p>A tiny package may consist of a single library with a single file, and not use any further features of the <code>package</code> keyword.</p>
<p>It is often useful to use separate files for the API and its implementation. This may help organize code as a library grows, or to let the build system distinguish between the dependencies of the API itself and its underlying implementation. Implementation files allow for code to be extracted out from the API file, while only being callable from other files within the library, including both API and implementation files. Implementation files are marked by both naming the file to use an extension of <code>.impl.carbon</code> and instead start with:</p>
<pre><code>package Geometry impl;</code></pre>
<p>However, as a package adds more files, it will probably want to separate out into multiple <em>libraries</em><sup><small>[<a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/guides/glossary.md#library">define</a>]</small></sup>. A library is the basic unit of <em>dependency</em>. Separating code into multiple libraries can speed up the overall build while also making it clear which code is being reused. For example, an API file adding the library <code>Shapes</code> to the <code>Geometry</code> package, or <code>Geometry//Shapes</code> in <a href="#shorthand-notation-for-libraries-in-packages">shorthand</a>, would start with:</p>
<pre><code>package Geometry library &quot;Shapes&quot; api;</code></pre>
<p>As code becomes more complex, and users pull in more code, it may also be helpful to add <em>namespaces</em><sup><small>[<a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/guides/glossary.md#namespace">define</a>]</small></sup> to give related entities consistently structured names. A namespace affects the <em>name path</em><sup><small>[<a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/guides/glossary.md#name-path">define</a>]</small></sup> used when calling code. For example, with no namespace, if a <code>Geometry</code> package defines <code>Circle</code> then the name path will be <code>Geometry.Circle</code>. However, it can be named <code>Geometry.TwoDimensional.Circle</code> with a <code>namespace</code>; for example:</p>
<pre><code>package Geometry library &quot;Shapes&quot; api;
namespace TwoDimensional;
struct TwoDimensional.Circle { ... };</code></pre>
<p>This scaling of packages into libraries and namespaces is how Carbon supports both small and large codebases.</p>
<h3 id="sizing-packages-and-libraries">Sizing packages and libraries</h3>
<p>A different way to think of the sizing of packages and libraries is:</p>
<ul>
<li>A package is a GitHub repository.
<ul>
<li>Small and medium projects that fit in a single repository will typically have a single package. For example, a medium-sized project like <a href="https://github.com/abseil/abseil-cpp/tree/master/absl">Abseil</a> could still use a single <code>Abseil</code> package.</li>
<li>Large projects will have multiple packages. For example, Mozilla may have multiple packages for Firefox and other efforts.</li>
</ul></li>
<li>A library is a few files that provide an interface and implementation, and should remain small.
<ul>
<li>Small projects will have a single library when it's easy to maintain all code in a few files.</li>
<li>Medium and large projects will have multiple libraries. For example, <a href="https://github.com/boostorg/geometry/blob/develop/include/boost/geometry/algorithms/detail/distance/interface.hpp">Boost Geometry's Distance</a> interface and implementation might be its own library within <code>Boost</code>, with dependencies on other libraries in <code>Boost</code> and potentially other packages from Boost.
<ul>
<li>Library names could be named after the feature, such as <code>library "Algorithms"</code>, or include part of the path to reduce the chance of name collisions, such as <code>library "Geometry/Algorithms"</code>.</li>
</ul></li>
</ul></li>
</ul>
<p>Packages may choose to expose libraries that expose unions of interfaces from other libraries within the package. However, doing so would also provide the transitive closure of build-time dependencies, and is likely to be discouraged in many cases.</p>
<h3 id="imports">Imports</h3>
<p>The <code>import</code> keyword supports reusing code from other files and libraries.</p>
<p>For example, to use <code>Geometry.Circle</code> from the <code>Geometry//Shapes</code> library:</p>
<pre class="carbon"><code>import Geometry library &quot;Shapes&quot;;

fn Area(circle: Geometry.Circle) { ... };</code></pre>
<p>The <code>library</code> keyword is optional for <code>import</code>, and its use should parallel that of <code>library</code> on the <code>package</code> of the code being imported.</p>
<h2 id="details">Details</h2>
<h3 id="source-file-introduction">Source file introduction</h3>
<p>Every source file will consist of, in order:</p>
<ol type="1">
<li>One <code>package</code> directive.</li>
<li>A section of zero or more <code>import</code> directives.</li>
<li>Source file body, with other code.</li>
</ol>
<p>Comments and blank lines may be intermingled with these sections. <a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/design/metaprogramming.md">Metaprogramming</a> code may also be intermingled, so long as the outputted code is consistent with the enforced ordering. Other types of code must be in the source file body.</p>
<h3 id="name-paths">Name paths</h3>
<p><a href="#name-paths">Name paths</a> are defined above as sequences of identifiers separated by dots. This syntax may be loosely expressed as a regular expression:</p>
<pre class="regex"><code>IDENTIFIER(\.IDENTIFIER)*</code></pre>
<p>Name conflicts are addressed by <a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/design/name_lookup.md">name lookup</a>.</p>
<h4 id="package-directives"><code>package</code> directives</h4>
<h3 id="packages">Packages</h3>
<p>The <code>package</code> directive's syntax may be loosely expressed as a regular expression:</p>
<pre class="regex"><code>package IDENTIFIER (library STRING)? (api|impl);</code></pre>
<p>For example:</p>
<pre class="carbon"><code>package Geometry library &quot;Objects/FourSides&quot; api;</code></pre>
<p>Breaking this apart:</p>
<ul>
<li>The identifier passed to the <code>package</code> keyword, <code>Geometry</code>, is the package name and will prefix both library and namespace paths.
<ul>
<li>The <code>package</code> keyword also declares a package entity matching the package name. A package entity is almost identical to a namespace entity, except with some package/import-specific handling. In other words, if the file declares <code>struct Line</code>, that may be used from within the file as both <code>Line</code> directly and <code>Geometry.TwoDimensional.Line</code> using the <code>Geometry</code> package entity created by the <code>package</code> keyword.</li>
</ul></li>
<li>When the optional <code>library</code> keyword is specified, sets the name of the library within the package. In this example, the <code>Geometry//Objects/FourSides</code> library will be used.</li>
<li>The use of the <code>api</code> keyword indicates this is an API files as described under <a href="#libraries">libraries</a>. If it instead had <code>impl</code>, this would be an implementation file.</li>
</ul>
<p>Because every file must have exactly one <code>package</code> directive, there are a couple important and deliberate side-effects:</p>
<ul>
<li>Every file will be in precisely one library.
<ul>
<li>A library still exists even when there is no explicit library argument, such as <code>package Geometry api;</code>. This could be considered equivalent to <code>package Geometry library "" api;</code>, although we should not allow that specific syntax as error-prone.</li>
</ul></li>
<li>Every entity in Carbon will be in a namespace, even if its namespace path consists of only the package name. There is no "global" namespace.
<ul>
<li>Every entity in a file will be defined within the namespace described in the <code>package</code> directive.</li>
<li>Entities within a file may be defined in <a href="#namespaces">child namespaces</a>.</li>
</ul></li>
</ul>
<p>Files contributing to the <code>Geometry//Objects/FourSides</code> library must all start with <code>package Geometry library "Objects/FourSides"</code>, but will differ on <code>api</code>/<code>impl</code> types.</p>
<h4 id="shorthand-notation-for-libraries-in-packages">Shorthand notation for libraries in packages</h4>
<p>Library names may also be referred to as <code>PACKAGE//LIBRARY</code> as shorthand in text. <code>PACKAGE//default</code> will refer to the name of the library used when no <code>library</code> argument is specified, although <code>PACKAGE</code> may also be used in situations where it is unambiguous that it still refers to the default library.</p>
<p>It's recommended that libraries use a single <code>/</code> for separators where desired, in order to distinguish between the <code>//</code> of the package and <code>/</code> separating library segments. For example, <code>Geometry//Objects/FourSides</code> uses a single <code>/</code> to separate the <code>Object/FourSides</code> library name.</p>
<h4 id="package-name-conflicts">Package name conflicts</h4>
<p>Because the package also declares a namespace entity with the same name, conflicts with the package name are possible. We do not support packages providing entities with the same name as the package.</p>
<p>For example, this is a conflict for <code>DateTime</code>:</p>
<pre class="carbon"><code>package DateTime api;

struct DateTime { ... };</code></pre>
<p>This declaration is important for <a href="#libraries">implementation files</a>, which implicitly import the library's API, because it keeps the package name as an explicit entity in source files.</p>
<p>Note that <a href="#package-and-library-name-conflicts">imported name conflicts</a> are handled differently.</p>
<h3 id="libraries">Libraries</h3>
<p>Every Carbon library consists of one or more files. Each Carbon library has a primary file that defines its API, and may optionally contain additional files that are implementation.</p>
<ul>
<li>An API file's <code>package</code> directive will have <code>api</code>. For example, <code>package Geometry library "Shapes" api;</code>
<ul>
<li>API filenames must have the <code>.carbon</code> extension. They must not have a <code>.impl.carbon</code> extension.</li>
<li>API file paths will correspond to the library name.
<ul>
<li>The precise form of this correspondence is undetermined, but should be expected to be similar to a "Math/Algebra" library being in a "Math/Algebra.carbon" file path.</li>
<li>The package will not be used when considering the file path.</li>
</ul></li>
</ul></li>
<li>An implementation file's <code>package</code> directive will have <code>impl</code>. For example, <code>package Geometry library "Shapes" impl;</code>.
<ul>
<li>Implementation filenames must have the <code>.impl.carbon</code> extension.</li>
<li>Implementation file paths need not correspond to the library name.</li>
<li>Implementation files implicitly import the library's API. Implementation files cannot import each other. There is no facility for file or non-<code>api</code> imports.</li>
</ul></li>
</ul>
<p>The difference between API and implementation will act as a form of access control. API files must compile independently of implementation, only importing from APIs from other libraries. API files are also visible to all files and libraries for import. Implementation files only see API files for import, not other implementation files.</p>
<p>When any file imports a library's API, it should be expected that the transitive closure of imported files from the primary API file will be a compilation dependency. The size of that transitive closure affects compilation time, so libraries with complex implementations should endeavor to minimize their API imports.</p>
<p>Libraries also serve as a critical unit of compilation. Dependencies between libraries must be clearly marked, and the resulting dependency graph will allow for separate compilation.</p>
<h4 id="exporting-entities-from-an-api-file">Exporting entities from an API file</h4>
<p>Entities in the API file are part of the library's public API by default. They may be marked as <code>private</code> to indicate they should only be visible to other parts of the library.</p>
<pre class="carbon"><code>package Geometry library &quot;Shapes&quot; api;

// Circle is an API, and will be available to other libraries as
 Geometry.Circle.
struct Circle { ... }

// CircleHelper is private, and so will not be available to other libraries.
private fn CircleHelper(circle: Circle) { ... }

// Only entities in namespaces should be marked as an API, not the namespace
// itself.
namespace Operations;

// Operations.GetCircumference is an API, and will be available to
// other libraries as Geometry.Operations.GetCircumference.
fn Operations.GetCircumference(circle: Circle) { ... }</code></pre>
<p>This means that an API file can contain all implementation code for a library. However, separate implementation files are still desirable for a few reasons:</p>
<ul>
<li>It will be easier for readers to quickly scan an API-only file for API documentation.</li>
<li>Reducing the amount of code in an API file can speed up compilation, especially if fewer imports are needed. This can result in transitive compilation performance improvements for files using the library.</li>
<li>From a code maintenance perspective, having smaller files can make a library more maintainable.</li>
</ul>
<p>Entities in the <code>impl</code> file should never have visibility keywords. If they are forward declared in the <code>api</code> file, they use the declaration's visibility; if they are only present in the <code>impl</code> file, they are implicitly <code>private</code>.</p>
<h4 id="granularity-of-libraries">Granularity of libraries</h4>
<p>The compilation graph of Carbon will generally consist of <code>api</code> files depending on each other, and <code>impl</code> files depending only on <code>api</code> files. Compiling a given file requires compiling the transitive closure of <code>api</code> files first. Parallelization of compilation is then limited by how large that transitive closure is, in terms of total volume of code rather than quantity. This also affects build cache invalidation.</p>
<p>In order to maximize opportunities to improve compilation performance, we will encourage granular libraries. Conceptually, we want libraries to be very small, possibly containing only a single class. The choice of only allowing a single <code>api</code> file per library should help encourage developers to write small libraries.</p>
<h4 id="exporting-namespaces">Exporting namespaces</h4>
<p>Any entity may be marked with <code>api</code> except for namespace and package entities. That is, <code>api namespace Sha256;</code> is invalid code. Instead, namespaces are implicitly exported based on the name paths of other entities marked as <code>api</code>.</p>
<p>For example, given this code:</p>
<pre class="carbon"><code>package Checksums library &quot;Sha&quot; api;

namespaces Sha256;

fn Sha256.HexDigest(data: Bytes) -&gt; String { ... }</code></pre>
<p>Calling code may look like:</p>
<pre class="carbon"><code>package Caller api;

import Checksums library &quot;Sha&quot;;

fn Process(data: Bytes) {
  ...
  var digest: String = Checksums.Sha256.HexDigest(data);
  ...
}</code></pre>
<p>In this example, the <code>Sha256</code> namespace is exported as part of the API implicitly.</p>
<h3 id="imports-1">Imports</h3>
<p><code>import</code> directives supports reusing code from other files and libraries. The <code>import</code> directive's syntax may be loosely expressed as a regular expression:</p>
<pre class="regex"><code>import IDENTIFIER (library NAME_PATH)?;</code></pre>
<p>An import declares a package entity named after the imported package, and makes API entities from the imported library available through it. The full name path is a concatenation of the names of the package entity, any namespace entities applied, and the final entity addressed. Child namespaces or entities may be <a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/design/aliases.md">aliased</a> if desired.</p>
<p>For example, given a library:</p>
<pre class="carbon"><code>package Math api;
namespace Trigonometry;
fn Trigonometry.Sin(...);</code></pre>
<p>Calling code would import it and use it like:</p>
<pre class="carbon"><code>package Geometry api;

import Math;

fn DoSomething() {
  ...
  Math.Trigonometry.Sin(...);
  ...
}</code></pre>
<p>Repeat imports from the same package reuse the same package entity. For example, this produces only one <code>Math</code> package entity:</p>
<pre class="carbon"><code>import Math;
import Math library &quot;Trigonometry&quot;;</code></pre>
<p>NOTE: A library must never import itself. Any <code>impl</code> files in a library automatically import the <code>api</code>, so a self-import should never be required.</p>
<h4 id="imports-from-the-current-package">Imports from the current package</h4>
<p>Entities defined in the current file may be used without mentioning the package prefix. However, other symbols from the package must be imported and accessed through the package namespace just like symbols from any other package.</p>
<p>For example:</p>
<pre class="carbon"><code>package Geometry api;

// This is required even though it&#39;s still in the Geometry package.
import Geometry library &quot;Shapes&quot;;

// Circle must be referenced using the Geometry namespace of the import.
fn GetArea(c: Geometry.Circle) { ... }</code></pre>
<h3 id="namespaces">Namespaces</h3>
<p>Namespaces offer named paths for entities. Namespaces may be nested. Multiple libraries may contribute to the same namespace. In practice, packages may have namespaces such as <code>Testing</code> containing entities that benefit from an isolated space but are present in many libraries.</p>
<p>The <code>namespace</code> keyword's syntax may loosely be expressed as a regular expression:</p>
<pre class="regex"><code>namespace NAME_PATH;</code></pre>
<p>The <code>namespace</code> keyword declares a namespace entity. The namespace is applied to other entities by including it as a prefix when declaring a name. For example:</p>
<pre class="carbon"><code>package Time;

namespace Timezones.Internal;
struct Timezones.Internal.RawData { ... }

fn ParseData(data: Timezones.Internal.RawData);</code></pre>
<p>A namespace declaration adds the first identifier in the name path as a name in the file's namespace. In the above example, after declaring <code>namespace Timezones.Internal;</code>, <code>Timezones</code> is available as an identifier and <code>Internal</code> is reached through <code>Timezones</code>.</p>
<h4 id="re-declaring-imported-namespaces">Re-declaring imported namespaces</h4>
<p>Namespaces may exist on imported package entities, in addition to being declared in the current file. However, even if the namespace already exists in an imported library from the current package, the namespace must still be declared locally in order to add symbols to it.</p>
<p>For example, if the <code>Geometry//Shapes/ThreeSides</code> library provides the <code>Geometry.Shapes</code> namespace, this code is still valid:</p>
<pre class="carbon"><code>package Geometry library &quot;Shapes/FourSides&quot; api;

import Geometry library &quot;Shapes/ThreeSides&quot;;

// This does not conflict with the existence of `Geometry.Shapes` from
// `Geometry//Shapes/ThreeSides`, even though the name path is identical.
namespace Shapes;

// This requires the above &#39;namespace Shapes&#39; declaration. It cannot use
// `Geometry.Shapes` from `Geometry//Shapes/ThreeSides`.
struct Shapes.Square { ... };</code></pre>
<h4 id="aliasing">Aliasing</h4>
<p>Carbon's <a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/design/aliases.md">alias keyword</a> will support aliasing namespaces. For example, this would be valid code:</p>
<pre class="carbon"><code>namespace Timezones.Internal;
alias TI = Timezones.internal;

struct TI.RawData { ... }
fn ParseData(data: TI.RawData);</code></pre>
<h2 id="caveats">Caveats</h2>
<h3 id="package-and-library-name-conflicts">Package and library name conflicts</h3>
<p>Library name conflicts should not occur, because it's expected that a given package is maintained by a single organization. It's the responsibility of that organization to maintain unique library names within their package.</p>
<p>A package name conflict occurs when two different packages use the same name, such as two packages named <code>Stats</code>. Versus libraries, package name conflicts are more likely because two organizations may independently choose identical names. We will encourage a unique package naming scheme, such as maintaining a name server for open source packages. Conflicts can also be addressed by renaming one of the packages, either at the source, or as a local modification.</p>
<p>We do need to address the case of package names conflicting with other entity names. It's possible that a pre-existing entity will conflict with a new import, and that renaming the entity is infeasible to rename due to existing callers. Alternately, the entity may be using an idiomatic name that it would contradict naming conventions to rename. In either case, this conflict may exist in a single file without otherwise affecting users of the API. This will be addressed by <a href="https://github.com/carbon-language/carbon-lang/tree/trunk/docs/design/name_lookup.md">name lookup</a>.</p>
<h3 id="potential-refactorings">Potential refactorings</h3>
<p>These are potential refactorings that we consider important to make it easy to automate.</p>
<h4 id="update-imports">Update imports</h4>
<p>Imports will frequently need to be updated as part of refactorings.</p>
<p>When code is deleted, it should be possible to parse the remaining code, parse the imports, and determine which entities in imports are referred to. Unused imports can then be removed.</p>
<p>When code is moved, it's similar to deletion in the originating file. For the destination file, the moved code should be parsed to determine which entities it referred to from the originating file's imports, and these will need to be included in the destination file: either reused if already present, or added.</p>
<p>When new code is added, existing imports can be checked to see if they provide the symbol in question. There may also be heuristics which can be implemented to check build dependencies for where imports should be added from, such as a database of possible entities and their libraries. However, adding references may require manually adding imports.</p>
<h4 id="between-api-and-impl-files">Between <code>api</code> and <code>impl</code> files</h4>
<ul>
<li><p>Move an implementation of an API from an <code>api</code> file to an <code>impl</code> file, while leaving a declaration behind.</p>
<ul>
<li>This should be a local change that will not affect any calling code.</li>
<li>Inlining will be affected because the implementation won't be visible to callers.</li>
<li><a href="#update-imports">Update imports</a>.</li>
</ul></li>
<li><p>Split an <code>api</code> and <code>impl</code> file.</p>
<ul>
<li>This is a repeated operation of individual API moves, as noted above.</li>
</ul></li>
<li><p>Move an implementation of an API from an <code>impl</code> file to an <code>api</code> file.</p>
<ul>
<li>This should be a local change that will not affect any calling code.</li>
<li>Inlining will be affected because the implementation becomes visible to callers.</li>
<li><a href="#update-imports">Update imports</a>.</li>
</ul></li>
<li><p>Combine an <code>api</code> and <code>impl</code> file.</p>
<ul>
<li>This is a repeated operation of individual API moves, as noted above.</li>
</ul></li>
<li><p>Remove the <code>api</code> label from a declaration.</p>
<ul>
<li>Search for library-external callers, and fix them first.</li>
</ul></li>
<li><p>Add the <code>api</code> label to a declaration.</p>
<ul>
<li>This should be a local change that will not affect any calling code.</li>
</ul></li>
<li><p>Move a non-<code>api</code>-labeled declaration from an <code>api</code> file to an <code>impl</code> file.</p>
<ul>
<li>The declaration must be moved to the same file as the implementation of the declaration.</li>
<li>The declaration can only be used by the <code>impl</code> file that now contains it. Search for other callers within the library, and fix them first.</li>
<li><a href="#update-imports">Update imports</a>.</li>
</ul></li>
<li><p>Move a non-<code>api</code>-labeled declaration from an <code>impl</code> file to an <code>api</code> file.</p>
<ul>
<li>This should be a local change that will not affect any calling code.</li>
<li><a href="#update-imports">Update imports</a>.</li>
</ul></li>
<li><p>Move a declaration and implementation from one <code>impl</code> file to another.</p>
<ul>
<li>Search for any callers within the source <code>impl</code> file, and either move them too, or fix them first.</li>
<li><a href="#update-imports">Update imports</a>.</li>
</ul></li>
</ul>
<h4 id="other-refactorings">Other refactorings</h4>
<ul>
<li><p>Rename a package.</p>
<ul>
<li>The imports of all calling files must be updated accordingly.</li>
<li>All call sites must be changed, as the package name changes.</li>
<li><a href="#update-imports">Update imports</a>.</li>
</ul></li>
<li><p>Move an <code>api</code>-labeled declaration and implementation between different packages.</p>
<ul>
<li>The imports of all calling files must be updated accordingly.</li>
<li>All call sites must be changed, as the package name changes.</li>
<li><a href="#update-imports">Update imports</a>.</li>
</ul></li>
<li><p>Move an <code>api</code>-labeled declaration and implementation between libraries in the same package.</p>
<ul>
<li>The imports of all calling files must be updated accordingly.</li>
<li>As long as the namespaces remain the same, no call sites will need to be changed.</li>
<li><a href="#update-imports">Update imports</a>.</li>
</ul></li>
<li><p>Rename a library.</p>
<ul>
<li>This is equivalent to a repeated operation of moving an <code>api</code>-labeled declaration and implementation between libraries in the same package.</li>
</ul></li>
<li><p>Move a declaration and implementation from one namespace to another.</p>
<ul>
<li>Ensure the new namespace is declared for the declaration and implementation.</li>
<li>Update the namespace used by call sites.</li>
<li>The imports of all calling files may remain the same.</li>
</ul></li>
<li><p>Rename a namespace.</p>
<ul>
<li>This is equivalent to a repeated operation of moving a declaration and implementation from one namespace to another.</li>
</ul></li>
<li><p>Rename a file, or move a file between directories.</p>
<ul>
<li>Build configuration will need to be updated.</li>
<li>This additionally requires the steps to rename a library, because library names must correspond to the renamed paths.</li>
</ul></li>
</ul>
<h3 id="preference-for-few-child-namespaces">Preference for few child namespaces</h3>
<p>We expect that most code should use a package and library, but avoid specifying namespaces beneath the package. The package name itself should typically be sufficient distinction for names.</p>
<p>Child namespaces create longer names, which engineers will dislike typing. Based on experience, we expect to start seeing aliasing even at name lengths around six characters long. With longer names, we should expect more aliasing, which in turn will reduce code readability because more types will have local names.</p>
<p>We believe it's feasible for even large projects to collapse namespaces down to a top level, avoiding internal tiers of namespaces.</p>
<p>We understand that child namespaces are sometimes helpful, and will robustly support them for that. However, we will model code organization to encourage fewer namespaces.</p>
<h3 id="redundant-markers">Redundant markers</h3>
<p>We use a few possibly redundant markers for packages and libraries:</p>
<ul>
<li>The <code>package</code> keyword requires one of <code>api</code> and <code>impl</code>, rather than excluding either or both.</li>
<li>The filename repeats the <code>api</code> versus <code>impl</code> choice.</li>
<li>The <code>import</code> keyword requires the full library.</li>
</ul>
<p>These choices are made to assist human readability and tooling:</p>
<ul>
<li>Being explicit about imports creates the opportunity to generate build dependencies from files, rather than having them maintained separately.</li>
<li>Being explicit about <code>api</code> versus <code>impl</code> makes it easier for both humans and tooling to determine what to expect.</li>
<li>Repeating the type in the filename makes it possible to check the type without reading file content.</li>
<li>Repeating the type in the file content makes non-file-system-based builds possible.</li>
</ul>
<h2 id="open-questions">Open questions</h2>
<p>These open questions are expected to be revisited by future proposals.</p>
<h3 id="different-file-extensions">Different file extensions</h3>
<p>Currently, we're using <code>.carbon</code> and <code>.impl.carbon</code>. In the future, we may want to change the extension, particularly because Carbon may be renamed.</p>
<p>There are several other possible extensions / commands that we've considered in coming to the current extension:</p>
<ul>
<li><code>.carbon</code>: This is an obvious and unsurprising choice, but also quite long for a file extension.</li>
<li><code>.6c</code>: This sounds a little like 'sexy' when read aloud.</li>
<li><code>.c6</code>: This seems a weird incorrect ordering of the atomic number and has a bad, if obscure, Internet slang association.</li>
<li><code>.cb</code> or <code>.cbn</code>: These collide with several acronyms and may not be especially memorable as referring to Carbon.</li>
<li><code>.crb</code>: This has a bad Internet slang association.</li>
</ul>
<h3 id="imports-from-other-languages">Imports from other languages</h3>
<p>Currently, we do not support cross-language imports. In the future, we will likely want to support imports from other languages, particularly for C++ interoperability.</p>
<p>To fit into the proposed <code>import</code> syntax, we are provisionally using a special <code>Cpp</code> package to import headers from C++ code, as in:</p>
<pre class="carbon"><code>import Cpp library &quot;&lt;map&gt;&quot;;
import Cpp library &quot;myproject/myclass.h&quot;;

fn MyCarbonCall(x: Cpp.std.map(Cpp.MyProject.MyClass));</code></pre>
<h3 id="imports-from-urls">Imports from URLs</h3>
<p>Currently, we don't support any kind of package management with imports. In the future, we may want to support tagging imports with a URL that identifies the repository where that package can be found. This can be used to help drive package management tooling and to support providing a non-name identity for a package that is used to enable handling conflicted package names.</p>
<p>Although we're not designing this right now, it could fit into the proposed syntax. For example:</p>
<pre class="carbon"><code>import Carbon library &quot;Utilities&quot;
    url(&quot;https://github.com/carbon-language/carbon-libraries&quot;);</code></pre>
<h3 id="test-file-type">Test file type</h3>
<p>Similar to <code>api</code> and <code>impl</code>, we may eventually want a type like <code>test</code>. This should be part of a larger testing plan.</p>
<h2 id="alternatives-considered">Alternatives considered</h2>
<ul>
<li>Packages
<ul>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#name-paths-for-package-names">Name paths for package names</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#referring-to-the-package-as-package">Referring to the package as <code>package</code></a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#remove-the-library-keyword-from-package-and-import">Remove the <code>library</code> keyword from <code>package</code> and <code>import</code></a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#rename-package-concept">Rename package concept</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#no-association-between-the-file-system-path-and-librarynamespace">No association between the file system path and library/namespace</a></li>
</ul></li>
<li>Libraries
<ul>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#allow-exporting-namespaces">Allow exporting namespaces</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#allow-importing-implementation-files-from-within-the-same-library">Allow importing implementation files from within the same library</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#alternative-library-separators-and-shorthand">Alternative library separators and shorthand</a>
<ul>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#single-word-libraries">Single-word libraries</a></li>
</ul></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#collapse-api-and-implementation-file-concepts">Collapse API and implementation file concepts</a>
<ul>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#automatically-generating-the-api-separation">Automatically generating the API separation</a></li>
</ul></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#collapse-file-and-library-concepts">Collapse file and library concepts</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#collapse-the-library-concept-into-packages">Collapse the library concept into packages</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#collapse-the-package-concept-into-libraries">Collapse the package concept into libraries</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0752.md#default-api-to-private">Default <code>api</code> to private</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0752.md#default-impl-to-public">Default <code>impl</code> to public</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#different-file-type-labels">Different file type labels</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#function-like-syntax">Function-like syntax</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#inlining-from-implementation-files">Inlining from implementation files</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#library-private-access-controls">Library-private access controls</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0752.md#make-keywords-either-optional-or-required-in-separate-definitions">Make keywords either optional or required in separate definitions</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#managing-api-versus-implementation-in-libraries">Managing API versus implementation in libraries</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#multiple-api-files">Multiple API files</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#name-paths-as-library-names">Name paths as library names</a></li>
</ul></li>
<li>Imports
<ul>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#block-imports">Block imports</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#block-imports-of-libraries-of-a-single-package">Block imports of libraries of a single package</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#broader-imports-either-all-names-or-arbitrary-code">Broader imports, either all names or arbitrary code</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#direct-name-imports">Direct name imports</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#optional-package-names">Optional package names</a></li>
</ul></li>
<li>Namespaces
<ul>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#file-level-namespaces">File-level namespaces</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0107.md#scoped-namespaces">Scoped namespaces</a></li>
</ul></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/107">#107: Code and name organization</a></li>
</ul>
