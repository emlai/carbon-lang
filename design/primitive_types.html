<h1 id="primitive-types">Primitive types</h1>
<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

<!-- toc -->

<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#todo">TODO</a></li>
<li><a href="#overview">Overview</a>
<ul>
<li><a href="#integers">Integers</a></li>
<li><a href="#floats">Floats</a></li>
<li><a href="#bfloat16">BFloat16</a></li>
</ul></li>
<li><a href="#open-questions">Open questions</a>
<ul>
<li><a href="#primitive-types-as-code-vs-built-in">Primitive types as code vs built-in</a></li>
<li><a href="#string-view-vs-owning-string">String view vs owning string</a></li>
<li><a href="#syntax-for-wrapping-operations">Syntax for wrapping operations</a></li>
<li><a href="#non-power-of-two-sizes">Non-power-of-two sizes</a></li>
</ul></li>
</ul>
<!-- tocstop -->

<h2 id="todo">TODO</h2>
<p>This is a skeletal design, added to support <a href="index.html">the overview</a>. It should not be treated as accepted by the core team; rather, it is a placeholder until we have more time to examine this detail. Please feel welcome to rewrite and update as appropriate.</p>
<h2 id="overview">Overview</h2>
<p>These types are fundamental to the language as they aren't either formed from or modifying other types. They also have semantics that are defined from first principles rather than in terms of other operations. These will be made available through the <a href="index.html#name-lookup-for-common-types">prelude package</a>.</p>
<ul>
<li><code>Bool</code> - a boolean type with two possible values: <code>True</code> and <code>False</code>.</li>
<li><code>Int</code> and <code>UInt</code> - signed and unsigned 64-bit integer types.
<ul>
<li>Standard sizes are available, both signed and unsigned, including <code>Int8</code>, <code>Int16</code>, <code>Int32</code>, <code>Int128</code>, and <code>Int256</code>.</li>
<li>Overflow in either direction is an error.</li>
</ul></li>
<li><code>Float64</code> - a floating point type with semantics based on IEEE-754.
<ul>
<li>Standard sizes are available, including <code>Float16</code>, <code>Float32</code>, and <code>Float128</code>.</li>
<li><a href="primitive_types.html#bfloat16"><code>BFloat16</code></a> is also provided.</li>
</ul></li>
<li><code>String</code> - a byte sequence treated as containing UTF-8 encoded text.
<ul>
<li><code>StringView</code> - a read-only reference to a byte sequence treated as containing UTF-8 encoded text.</li>
</ul></li>
</ul>
<h3 id="integers">Integers</h3>
<p>Integer types can be either signed or unsigned, much like in C++. Signed integers are represented using 2's complement and notionally modeled as unbounded natural numbers. Overflow in either direction is an error. That includes unsigned integers, differing from C++. The default size for both is 64-bits: <code>Int</code> and <code>UInt</code>. Specific sizes are also available, for example: <code>Int8</code>, <code>Int16</code>, <code>Int32</code>, <code>Int128</code>, <code>UInt256</code>. Arbitrary powers of two above <code>8</code> are supported for both (although perhaps we'll want to avoid <em>huge</em> values for implementation simplicity).</p>
<h3 id="floats">Floats</h3>
<p>Floating point types are based on the binary floating point formats provided by IEEE-754. <code>Float16</code>, <code>Float32</code>, <code>Float64</code> and <code>Float128</code> correspond exactly to those sized IEEE-754 formats, and have the semantics defined by IEEE-754.</p>
<h3 id="bfloat16">BFloat16</h3>
<p>Carbon also supports the <a href="https://en.wikipedia.org/wiki/Bfloat16_floating-point_format"><code>BFloat16</code></a> format, a 16-bit truncation of a "binary32" IEEE-754 format floating point number.</p>
<h2 id="open-questions">Open questions</h2>
<h3 id="primitive-types-as-code-vs-built-in">Primitive types as code vs built-in</h3>
<p>There are open questions about the extent to which these types should be defined in Carbon code rather than special. Clearly they can't be directly implemented w/o help, but it might still be useful to force the programmer-observed interface to reside in code. However, this can cause difficulty with avoiding the need to import things gratuitously.</p>
<h3 id="string-view-vs-owning-string">String view vs owning string</h3>
<p>The right model of a string view versus an owning string is still very much unsettled.</p>
<h3 id="syntax-for-wrapping-operations">Syntax for wrapping operations</h3>
<p>Open question around allowing special syntax for wrapping operations (even on signed types) and/or requiring such syntax for wrapping operations on unsigned types.</p>
<h3 id="non-power-of-two-sizes">Non-power-of-two sizes</h3>
<p>Supporting non-power-of-two sizes is likely needed to have a clean model for bitfields, but requires more details to be worked out around memory access.</p>
