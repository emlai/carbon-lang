<h1 id="naming-conventions">Naming conventions</h1>
<!--
Part of the Carbon Language project, under the Apache License v2.0 with LLVM
Exceptions. See /LICENSE for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-->

<!-- toc -->

<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#details">Details</a>
<ul>
<li><a href="#constants">Constants</a></li>
<li><a href="#carbon-provided-item-naming">Carbon-provided item naming</a></li>
</ul></li>
<li><a href="#alternatives-considered">Alternatives considered</a></li>
<li><a href="#references">References</a></li>
</ul>
<!-- tocstop -->

<h2 id="overview">Overview</h2>
<p>Our naming conventions are:</p>
<ul>
<li>For idiomatic Carbon code:
<ul>
<li><code>UpperCamelCase</code> will be used when the named entity cannot have a dynamically varying value. For example, functions, namespaces, or compile-time constant values.</li>
<li><code>lower_snake_case</code> will be used when the named entity's value won't be known until runtime, such as for variables.</li>
</ul></li>
<li>For Carbon-provided features:
<ul>
<li>Keywords and type literals will use <code>lower_snake_case</code>.</li>
<li>Other code will use the guidelines for idiomatic Carbon code.</li>
</ul></li>
</ul>
<p>In other words:</p>
<table>
<thead>
<tr class="header">
<th>Item</th>
<th>Convention</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Packages</td>
<td><code>UpperCamelCase</code></td>
<td>Used for compile-time lookup.</td>
</tr>
<tr class="even">
<td>Types</td>
<td><code>UpperCamelCase</code></td>
<td>Resolved at compile-time.</td>
</tr>
<tr class="odd">
<td>Functions</td>
<td><code>UpperCamelCase</code></td>
<td>Resolved at compile-time.</td>
</tr>
<tr class="even">
<td>Methods</td>
<td><code>UpperCamelCase</code></td>
<td>Methods, including virtual methods, are equivalent to functions.</td>
</tr>
<tr class="odd">
<td>Generic parameters</td>
<td><code>UpperCamelCase</code></td>
<td>May vary based on inputs, but are ultimately resolved at compile-time.</td>
</tr>
<tr class="even">
<td>Compile-time constants</td>
<td><code>UpperCamelCase</code></td>
<td>Resolved at compile-time. See <a href="#constants">constants</a> for more remarks.</td>
</tr>
<tr class="odd">
<td>Variables</td>
<td><code>lower_snake_case</code></td>
<td>May be reassigned and thus require runtime information.</td>
</tr>
<tr class="even">
<td>Member variables</td>
<td><code>lower_snake_case</code></td>
<td>Behave like variables.</td>
</tr>
<tr class="odd">
<td>Keywords</td>
<td><code>lower_snake_case</code></td>
<td>Special, and developers can be expected to be comfortable with this casing cross-language.</td>
</tr>
<tr class="even">
<td>Type literals</td>
<td><code>lower_snake_case</code></td>
<td>Equivalent to keywords.</td>
</tr>
<tr class="odd">
<td>Boolean type and literals</td>
<td><code>lower_snake_case</code></td>
<td>Equivalent to keywords.</td>
</tr>
<tr class="even">
<td>Other Carbon types</td>
<td><code>UpperCamelCase</code></td>
<td>Behave like normal types.</td>
</tr>
<tr class="odd">
<td><code>Self</code> and <code>Base</code></td>
<td><code>UpperCamelCase</code></td>
<td>These are similar to type members on a class.</td>
</tr>
</tbody>
</table>
<p>We only use <code>UpperCamelCase</code> and <code>lower_snake_case</code> in naming conventions in order to minimize the variation in rules.</p>
<h2 id="details">Details</h2>
<h3 id="constants">Constants</h3>
<p>Consider the following code:</p>
<pre class="carbon"><code>package Example;

let CompileTimeConstant: i32 = 7;

fn RuntimeFunction(runtime_constant: i32);</code></pre>
<p>In this example, <code>CompileTimeConstant</code> has a singular value (<code>7</code>) which is known at compile-time. As such, it uses <code>UpperCamelCase</code>.</p>
<p>On the other hand, <code>runtime_constant</code> may be constant within the function body, but it is assigned at runtime when <code>RuntimeFunction</code> is called. Its value is only known in a given runtime invocation of <code>RuntimeFunction</code>. As such, it uses <code>lower_snake_case</code>.</p>
<h3 id="carbon-provided-item-naming">Carbon-provided item naming</h3>
<p>Carbon-provided items are split into a few categories:</p>
<ul>
<li>Keywords; for example, <code>for</code>, <code>fn</code>, and <code>var</code>.</li>
<li>Type literals; for example, <code>i&lt;digits&gt;</code>, <code>u&lt;digits&gt;</code>, and <code>f&lt;digits&gt;</code>.</li>
<li>Boolean type and literals; for example, <code>bool</code>, <code>true</code>, and <code>false</code>.
<ul>
<li>The separate categorization of booleans should not be taken as a rule that only booleans would use lowercase; it's just the only example right now.</li>
</ul></li>
<li><code>Self</code> and <code>Base</code>.</li>
<li>Other Carbon types; for example, <code>Int</code>, <code>UInt</code>, and <code>String</code>.</li>
</ul>
<p>Note that while other Carbon types currently use <code>UpperCamelCase</code>, that should not be inferred to mean that future Carbon types will do the same. The leads will make decisions on future naming.</p>
<h2 id="alternatives-considered">Alternatives considered</h2>
<ul>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0861.md#other-naming-conventions">Other naming conventions</a></li>
<li><a href="https://github.com/carbon-language/carbon-lang/tree/trunk/proposals/p0861.md#other-conventions-for-naming-carbon-types">Other conventions for naming Carbon types</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>Proposal <a href="https://github.com/carbon-language/carbon-lang/pull/861">#861: Naming conventions</a></li>
</ul>
