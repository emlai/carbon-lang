"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3695],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),c=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return i.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),d=a,f=u["".concat(s,".").concat(d)]||u[d]||m[d]||r;return n?i.createElement(f,o(o({ref:t},p),{},{components:n})):i.createElement(f,o({ref:t},p))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<r;c++)o[c]=n[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8766:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var i=n(7462),a=(n(7294),n(3905));const r={},o="Principle: Information accumulation",l={unversionedId:"principles/information_accumulation",id:"principles/information_accumulation",title:"Principle: Information accumulation",description:"\x3c!--",source:"@site/../docs/project/principles/information_accumulation.md",sourceDirName:"principles",slug:"/principles/information_accumulation",permalink:"/project/principles/information_accumulation",draft:!1,editUrl:"https://github.com/carbon-language/carbon-lang/blob/trunk/../docs/project/principles/information_accumulation.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Principle: Errors are values",permalink:"/project/principles/error_handling"},next:{title:"Principle: All APIs are library APIs",permalink:"/project/principles/library_apis_only"}},s={},c=[{value:"Table of contents",id:"table-of-contents",level:2},{value:"Background",id:"background",level:2},{value:"Principle",id:"principle",level:2},{value:"Applications of this principle",id:"applications-of-this-principle",level:2},{value:"Exceptions",id:"exceptions",level:2},{value:"Alternatives considered",id:"alternatives-considered",level:2}],p={toc:c};function m(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"principle-information-accumulation"},"Principle: Information accumulation"),(0,a.kt)("h2",{id:"table-of-contents"},"Table of contents"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#background"},"Background")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#principle"},"Principle")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#applications-of-this-principle"},"Applications of this principle")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#exceptions"},"Exceptions")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#alternatives-considered"},"Alternatives considered"))),(0,a.kt)("h2",{id:"background"},"Background"),(0,a.kt)("p",null,"There are many different sources of information in a program, and a tool or a\nhuman interpreting code will not in general have full information, but will\nstill want to draw conclusions about the code."),(0,a.kt)("p",null,"Different languages take different approaches to this problem. For example:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"In C, information is accumulated linearly in each source file independently,\nand only information from earlier in the same file is available. A program\ncan observe that information is incomplete at one point and complete at\nanother."),(0,a.kt)("li",{parentName:"ul"},"In C++, the behavior is largely similar to C, except:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Within certain contexts in a class, information from later in the class\ndefinition is available."),(0,a.kt)("li",{parentName:"ul"},"With C++20 modules, information from other source files can be made\navailable."),(0,a.kt)("li",{parentName:"ul"},"It is easier to observe -- perhaps even accidentally -- that information\nis accumulated incrementally."))),(0,a.kt)("li",{parentName:"ul"},"In Rust, all information from the entire crate is available everywhere\nwithin that crate, with exceptions for constructs like proc macros that can\nsee the state of the program being incrementally built."),(0,a.kt)("li",{parentName:"ul"},"In Swift, all information from the entire source file is available within\nthat source file.")),(0,a.kt)("h2",{id:"principle"},"Principle"),(0,a.kt)("p",null,"In Carbon, information is accumulated incrementally within each source file.\nCarbon programs are invalid if they would have a different meaning if more\ninformation were available."),(0,a.kt)("p",null,"Carbon source files can be interpreted top-down, without referring to\ninformation that appears substantially later in a file. Source files are\nexpected to be organized into a topological order where that makes sense, with\nforward declarations used to introduce names before they are first referenced\nwhen necessary."),(0,a.kt)("p",null,"If a program attempts to use information that has not yet been provided, the\nprogram is invalid. There are multiple options for how this can be reported:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The program can be rejected as soon as it tries to use information that\nmight not be known yet."),(0,a.kt)("li",{parentName:"ul"},"For the case where the information can only be provided in the same source\nfile, an assumption about the information can be made at the point where it\nis needed, and the program can be rejected only if that assumption turns out\nto be incorrect.")),(0,a.kt)("p",null,"Disallowing programs from changing meaning in the context of more information\nensures that the program is interpreted consistently or is rejected. This is\nespecially important to the coherence of generics and templates."),(0,a.kt)("h2",{id:"applications-of-this-principle"},"Applications of this principle"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"As in C++, and unlike in Rust and Swift, name lookup only finds names\ndeclared earlier."),(0,a.kt)("li",{parentName:"ul"},"Classes are incomplete until the end of their definition. Unlike in C++, any\nattempt to observe a property of an incomplete class that is not known until\nthe class is complete renders the program invalid."),(0,a.kt)("li",{parentName:"ul"},"When an ",(0,a.kt)("inlineCode",{parentName:"li"},"impl")," needs to be resolved, only those ",(0,a.kt)("inlineCode",{parentName:"li"},"impl"),"s that have already\nbeen declared are considered. However, if a later ",(0,a.kt)("inlineCode",{parentName:"li"},"impl")," would change the\nresult of any earlier ",(0,a.kt)("inlineCode",{parentName:"li"},"impl")," lookup, the program is invalid.")),(0,a.kt)("h2",{id:"exceptions"},"Exceptions"),(0,a.kt)("p",null,"Because a class is not complete until its definition has been fully parsed,\napplying this rule would make it impossible to define most member functions\nwithin the class definition. In order to still provide the convenience of\ndefining class member functions inline, such member function bodies are deferred\nand processed as if they appeared immediately after the end of the outermost\nenclosing class, like in C++."),(0,a.kt)("h2",{id:"alternatives-considered"},"Alternatives considered"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Allow information to be used before it is provided\n",(0,a.kt)("a",{parentName:"li",href:"/proposals/p0875.md#strict-global-consistency"},"globally"),",\n",(0,a.kt)("a",{parentName:"li",href:"/proposals/p0875.md#context-sensitive-local-consistency"},"within a file"),", or\n",(0,a.kt)("a",{parentName:"li",href:"/proposals/p0875.md#top-down-with-minimally-deferred-type-checking"},"within a top-level declaration"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/proposals/p0875.md#strict-top-down"},"Do not allow inline method bodies to use members before they are declared")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/proposals/p0875.md#disallow-separate-declaration-and-definition"},"Do not allow separate declaration and definition"))))}m.isMDXComponent=!0}}]);